<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="GENERATOR" content="Microsoft FrontPage 5.0">
  <title>Motor Record and related software</title>
</head>

<body>

<h1>Motor Record and related software</h1>

<address>Tim Mooney, Joe Sullivan, Ron Sluiter</address> <br>

<hr>
<h2>Contents</h2>

<ul>
  <li>
    <a href="#Overview">Overview</a>
  </li>
  <li>
    <a href="#Fields">Field Descriptions</a>
  </li>
  <li>
    <a href="#Files">Files, device-support</a>
  </li>
  <li>
    <a href="#Restrictions">Restrictions</a>
  </li>
  <li>
    <a href="#Examples">Examples</a>
  </li>
  <li>
    <a href="#Design_Decisions">Design Decisions</a>
  </li>
</ul>
<a name="Overview"></a>

<h2>Overview</h2> This documentation describes version R6-5 of the EPICS motor
record, and related EPICS software required to build and use it.&nbsp; Version
R6-5 of the motor record is compatible with EPICS base R3.14.10 and above.
<p>
The motor record is intended to support motors of all kinds, but currently 
supports only the following variety of motor controllers (in addition to Soft 
Channel support):
</p>

<ul>
  <li>
    Oregon Micro Systems, Inc. (OMS) models; VME8, VME44, VME58, VS4, VX2, MAXv, PC68 and PC78.
  </li>
  <li>
    Highland Technologies model V540.
  </li>
  <li>
    Newport models MM3000, MM4000/5/6, PM500, ESP300/301/100 and XPSC8.
  </li>
  <li>
    Intelligent Motion Systems, Inc. (IMS) models IM483 and MDrive.
  </li>
  <li>
    Advanced Control Systems, Corp. model MCB-4B.
  </li>
  <li>
    Mclennan models PM304 and PM600.
  </li>
  <LI>
    Physik Instrumente (PI) GmbH & Co. model C-630, C-844, C-848, C-862, E-662, E-710 and E-816.
  </LI>
  <li>
    MicroMo model MVP 2001 B02.
  </li>
  <li>
    Micos model MoCo dc controller.
  </li>
  <li>
    Delta Tau PMAC2-VME controller.
  </li>
  <li>
    Faulhaber MCDC2805 servo controller.
  <li>
    Parker Hannifin, Compumotor Division, 6K Series controllers.
  </li>
  <li>
    New Focus, models; 8750 and 8752.
  </li>
  <li>
    ACS Motion Control, SPiiPlus model.
  </li>
  <li>
    Spectra-Physics, Encoder Mike Controller, Model 18011.
  </li>
  <li>
    Thorlabs, Piezo Controller, Model MDT695.
  </li>
  <li>
    Animatics Corporation SmartMotor.
  </li>
  <li>
    piezosystem jena GmbH EDS data interface module.
  </li>
  <li>
    Kohzu SC-200, SC-400, SC-800 stepper motor controllers.
  </li>
  <li>
    attocube systems AG ANC150 Piezo Step Controller.
  </li>
  <li>
    Aerotech Ensemble digital servo controller.
  </li>
</ul>
The record maintains two coordinate systems for motor position ("user" and "dial 
" coordinates); displays drive and readback values; enforces limits to motor 
motion and maintains those limits in both coordinate systems; displays the 
states of limit switches; can use a home switch; optionally takes out backlash 
in a user-defined direction; and provides a mechanism by which the user and 
other EPICS records can recalibrate the motor position in either coordinate 
system. The record also supports "tweak", "jog", and "home" motions, and 
supports both absolute and relative motions in user coordinates. Two "stop" 
switches are provided: a simple one for use by other records and by channel-access 
clients, and a more versatile one for interactive use.
<p>
Except where specified otherwise, fields associated with the motor position and 
its derivatives take values in user-specified "engineering units", such as 
degrees; the engineering unit name is contained in the field EGU. Thus, 
generally, speeds are expressed in EGU's per second. Accelerations, however, are 
expressed as the number of seconds taken to accelerate to full speed. However, 
additional fields are provided so that the motor position can be specified in 
steps and the speed in revolutions per second, and so that the step size can be 
set by specifying the number of steps per revolution and the number of EGU's per 
revolution.
</p>

<p>
The motor record can read motor position from the controller's readback register 
or encoder register, or from any other EPICS record, via an EPICS input link. 
While the motor is moving, the record can trigger an output link periodically, 
to send readback information to other EPICS records. When a complete motion (possibly 
including backlash takeout) is finished, the record can trigger a forward link 
to process other EPICS records.
</p>

<p>
The motor record can force its drive fields to agree with its readback fields, 
and it does so in a variety of circumstances (e.g., when the user tells a motor 
to stop, and when a limit switch is hit). Therefore, if you are driving the 
motor record's VAL or DVAL field with the output of another record, and you want 
that record always to contain the same value as the motor record, you must 
handle this behavior in the database. One way to do this is to forward link the 
motor record to a soft analog output record, and to cause that AO record to grab 
the motor record's VAL or DVAL field and poke it into your record.
</p>

<p>
The motor record is unlike most other EPICS records in that its processing is 
neither "synchronous" nor "asynchronous", as these terms are used in the EPICS 
Record Reference Manual. Currently, the PACT field is always FALSE after record 
processing has completed, even though a motor motion may be in progress. This 
means the record always responds to channel-access puts, and can be stopped or 
retargeted at any time. The record's forward link is not executed until the 
motor has stopped and no motion requests are pending.&nbsp;<a name="Fields"></a>
</p>

<h2>Field Descriptions</h2> In addition to fields common to all record types (see 
the <a href="http://www.atdiv.lanl.gov/aot8/epics/dbase/recref/rcrf-1.html">EPICS 
Record Reference Manual</a> for these) the motor record has the fields described
below.
<ul>
  <li>
    <a href="#Fields_alphabetical">Alphabetical listing of all fields</a>
  </li>
  <li>
    <a href="#Fields_calib">Calibration-related fields:</a>
  </li>
  <li>
    <a href="#Fields_command">Command-button fields:</a>
  </li>
  <li>
    <a href="#Fields_res">Motor-resolution fields:</a>
  </li>
  <li>
    <a href="#Fields_motion">Motion-related fields:</a>
  </li>
  <li>
    <a href="#Fields_link">Link-related fields</a>
  </li>
  <li>
    <a href="#Fields_limit">Limit-related fields</a>
  </li>
  <li>
    <a href="#Fields_drive">Drive fields</a>
  </li>
  <li>
    <a href="#Fields_status">Status/readback fields</a>
  </li>
  <li>
    <a href="#Servo_fields">Servo fields</a>
  </li>
  <li>
    <a href="#Fields_alarm">Alarm fields</a>
  </li>
  <li>
    <a href="#Fields_misc">Miscellaneous fields</a>
  </li>
  <li>
    <a href="#Fields_private">Private fields</a>
  </li>
</ul>

<hr>
<table border="1" nosave="">
  <caption>
    <a name="Fields_alphabetical"></a> <h2>Alphabetical list of record-specific 
    fields</h2> NOTE: Hot links in this table take you only to the <i>section</i> in 
    which the linked item is described in detail. You'll probably have to scroll 
    down to find the actual item.
  </caption>
  <tbody>
  <tr>
    <th>Name</th>
    <th>Access</th>
    <th>Prompt</th>
    <th>Data type</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><a href="#Fields_motion">ACCL</a></td>
    <td>R/W</td>
    <td>Seconds to Velocity</td>
    <td>DOUBLE</td>
    <td>acceleration time</td>
  </tr>
  <tr>
    <td><a href="#Fields_status">ATHM</a></td>
    <td>R</td>
    <td>At HOME</td>
    <td>SHORT</td>
    <td>uses the HOME switch</td>
  </tr>
  <tr>
    <td><a href="#Fields_motion">BACC</a></td>
    <td>R/W</td>
    <td>BL Seconds to Veloc.</td>
    <td>DOUBLE</td>
    <td>backlash acceleration time</td>
  </tr>
  <tr>
    <td><a href="#Fields_motion">BDST</a></td>
    <td>R/W</td>
    <td>BL Distance (EGU)</td>
    <td>DOUBLE</td>
    <td>backlash distance</td>
  </tr>
  <tr>
    <td><a href="#Fields_motion">BVEL</a></td>
    <td>R/W</td>
    <td>BL Velocity (EGU/s)</td>
    <td>DOUBLE</td>
    <td>backlash speed</td>
  </tr>
  <tr>
    <td><a href="#Fields_misc">CARD</a></td>
    <td>R</td>
    <td>Card Number</td>
    <td>SHORT</td>
    <td>EPICS card #</td>
  </tr>
  <tr>
    <td><a href="#Fields_private">CBAK</a></td>
    <td>None</td>
    <td>Callback structure</td>
    <td>NOACCESS</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_private">CDIR</a></td>
    <td>R</td>
    <td>Raw commanded direction</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Servo_fields">CNEN</a></td>
    <td>R/W</td>
    <td>Enable control</td>
    <td>RECCHOICE</td>
    <td>(0:"Disable", 1:"Enable")</td>
  </tr>
  <tr>
    <td><a href="#Servo_fields">DCOF</a></td>
    <td>R/W</td>
    <td>Derivative Gain</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_limit">DHLM</a></td>
    <td>R/W*</td>
    <td>Dial High Limit</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_status">DIFF</a></td>
    <td>R</td>
    <td>Difference dval-drbv</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_link">DINP</a></td>
    <td>R/W</td>
    <td>DMOV Input Link</td>
    <td>INLINK</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_calib">DIR</a></td>
    <td>R/W*</td>
    <td>User Direction</td>
    <td>RECCHOICE</td>
    <td>(0:"Pos", 1:"Neg")</td>
  </tr>
  <tr>
    <td><a href="#Fields_limit">DLLM</a></td>
    <td>R/W*</td>
    <td>Dial Low Limit</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_status">DLY</a></td>
    <td>R/W</td>
    <td>Readback settle time (s)</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_status">DMOV</a></td>
    <td>R</td>
    <td>Done moving to value</td>
    <td>SHORT</td>
    <td>The "done" flag</td>
  </tr>
  <tr>
    <td><a href="#Fields_link">DOL</a></td>
    <td>R</td>
    <td>Desired Output Loc</td>
    <td>INLINK</td>
    <td>only for closed-loop mode</td>
  </tr>
  <tr>
    <td><a href="#Fields_status">DRBV</a></td>
    <td>R</td>
    <td>Dial Readback Value</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_drive">DVAL</a></td>
    <td>R/W*</td>
    <td>Dial Desired Value</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_misc">EGU</a></td>
    <td>R/W</td>
    <td>Engineering Units</td>
    <td>STRING</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_res">ERES</a></td>
    <td>R/W*</td>
    <td>Encoder Step Size (EGU)</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_calib">FOF</a></td>
    <td>R/W</td>
    <td>Freeze Offset</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_calib">FOFF</a></td>
    <td>R/W</td>
    <td>Offset-Freeze Switch</td>
    <td>RECCHOICE</td>
    <td>(0:"Variable", 1:"Frozen")</td>
  </tr>
  <tr>
    <td><a href="#Fields_motion">FRAC</a></td>
    <td>R/W</td>
    <td>Move Fraction</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_alarm">HHSV</a></td>
    <td>R/W*</td>
    <td>Hihi Severity</td>
    <td>GBLCHOICE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_alarm">HIGH</a></td>
    <td>R/W*</td>
    <td>High Alarm Limit</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_alarm">HIHI</a></td>
    <td>R/W*</td>
    <td>Hihi Alarm Limit</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_limit">HLM</a></td>
    <td>R/W*</td>
    <td>User High Limit</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_limit">HLS</a></td>
    <td>R</td>
    <td>At High Limit Switch</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_alarm">HLSV</a></td>
    <td>R/W*</td>
    <td>HW Lim. Violation Svr</td>
    <td>GBLCHOICE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_command">HOMF</a></td>
    <td>R/W*</td>
    <td>Home Forward</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_command">HOMR</a></td>
    <td>R/W*</td>
    <td>Home Reverse</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_limit">HOPR</a></td>
    <td>R/W</td>
    <td>High Operating Range</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_alarm">HSV</a></td>
    <td>R/W*</td>
    <td>High Severity</td>
    <td>GBLCHOICE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_motion">HVEL</a></td>
    <td>R/W*</td>
    <td>Home Velocity</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Servo_fields">ICOF</a></td>
    <td>R/W</td>
    <td>Integral Gain</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_misc">INIT</a></td>
    <td>R/W</td>
    <td>Startup commands</td>
    <td>STRING</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_motion">JAR</a></td>
    <td>R/W</td>
    <td>Jog Acceleration (EGU/s^2)</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_command">JOGF</a></td>
    <td>R/W*</td>
    <td>Jog motor Forward</td>
    <td>SHORT</td>
    <td>careful!</td>
  </tr>
  <tr>
    <td><a href="#Fields_command">JOGR</a></td>
    <td>R/W*</td>
    <td>Jog motor Reverse</td>
    <td>SHORT</td>
    <td>careful!</td>
  </tr>
  <tr>
    <td><a href="#Fields_motion">JVEL</a></td>
    <td>R/W</td>
    <td>Jog Velocity</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_private">LDVL</a></td>
    <td>R</td>
    <td>Last Dial Des Val</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_limit">LLM</a></td>
    <td>R/W*</td>
    <td>User Low Limit</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_limit">LLS</a></td>
    <td>R</td>
    <td>At Low Limit Switch</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_alarm">LLSV</a></td>
    <td>R/W*</td>
    <td>Lolo Severity</td>
    <td>GBLCHOICE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_misc">LOCK</a></td>
    <td>R/W*</td>
    <td>Soft Channel Position Lock</td>
    <td>RECCHOICE</td>
    <td>(0:"NO", 1:"YES")</td>
  </tr>
  <tr>
    <td><a href="#Fields_alarm">LOLO</a></td>
    <td>R/W*</td>
    <td>Lolo Alarm Limit</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_limit">LOPR</a></td>
    <td>R/W</td>
    <td>Low Operating Range</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_alarm">LOW</a></td>
    <td>R/W*</td>
    <td>Low Alarm Limit</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_private">LRLV</a></td>
    <td>R</td>
    <td>Last Rel Value</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_private">LRVL</a></td>
    <td>R</td>
    <td>Last Raw Des Val</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_private">LSPG</a></td>
    <td>R</td>
    <td>Last SPMG</td>
    <td>RECCHOICE</td>
    <td>(See SPMG)</td>
  </tr>
  <tr>
    <td><a href="#Fields_alarm">LSV</a></td>
    <td>R/W*</td>
    <td>Low Severity</td>
    <td>GBLCHOICE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_private">LVAL</a></td>
    <td>R</td>
    <td>Last User Des Val</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_limit">LVIO</a></td>
    <td>R</td>
    <td>Limit violation</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_private">MIP</a></td>
    <td>R</td>
    <td>Motion In Progress</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_status">MISS</a></td>
    <td>R</td>
    <td>Ran out of retries</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_private">MMAP</a></td>
    <td>R</td>
    <td>Monitor Mask</td>
    <td>ULONG</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_status">MOVN</a></td>
    <td>R</td>
    <td>Motor is moving</td>
    <td>SHORT</td>
    <td>Don't confuse with DMOV</td>
  </tr>
  <tr>
    <td><a href="#Fields_res">MRES</a></td>
    <td>R/W*</td>
    <td>Motor Step Size (EGU)</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_status">MSTA</a></td>
    <td>R</td>
    <td>Motor Status</td>
    <td>ULONG</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_private">NMAP</a></td>
    <td>R</td>
    <td>Monitor Mask</td>
    <td>ULONG</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_misc">NTM</a></td>
    <td>R/W*</td>
    <td>New Target Monitor</td>
    <td>RECCHOICE</td>
    <td>(0:"NO", 1:"YES")</td>
  </tr>
  <tr>
    <td><a href="#Fields_misc">NTMF</a></td>
    <td>R/W*</td>
    <td>New Target Monitor Deadband Factor</td>
    <td>SHORT</td>
    <td>Determines NTM deadband; NTMF >= 2</td>
  </tr>
  <tr>
    <td><a href="#Fields_calib">OFF</a></td>
    <td>R/W</td>
    <td>User Offset (EGU)</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_link">OMSL</a></td>
    <td>R/W</td>
    <td>Output Mode Select</td>
    <td>GBLCHOICE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_link">OUT</a></td>
    <td>R/W</td>
    <td>Output Specification</td>
    <td>OUTLINK</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Servo_fields">PCOF</a></td>
    <td>R/W</td>
    <td>Proportional Gain</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_limit">PERL</a></td>
    <td>R/W</td>
    <td>Periodic Limits</td>
    <td>RECCHOICE</td>
    <td>(0:"NO", 1:"YES")</td>
  </tr>
  <tr>
    <td><a href="#Fields_misc">POST</a></td>
    <td>R/W</td>
    <td>Post-move commands</td>
    <td>STRING</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_private">PP</a></td>
    <td>R</td>
    <td>Post process command</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_misc">PREC</a></td>
    <td>R/W</td>
    <td>Display Precision</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_misc">PREM</a></td>
    <td>R/W</td>
    <td>Pre-move commands</td>
    <td>STRING</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_status">RBV</a></td>
    <td>R</td>
    <td>User Readback Value</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_status">RCNT</a></td>
    <td>R</td>
    <td>Retry count</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_motion">RDBD</a></td>
    <td>R/W</td>
    <td>Retry Deadband (EGU)</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_link">RDBL</a></td>
    <td>R</td>
    <td>Readback Location</td>
    <td>INLINK</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_status">RDIF</a></td>
    <td>R</td>
    <td>Difference rval-rrbv</td>
    <td>LONG</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_status">REP</a></td>
    <td>R</td>
    <td>Raw Encoder Position</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_limit">RHLS</a></td>
    <td>R</td>
    <td>Raw High Limit Switch</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_link">RINP</a></td>
    <td>R/W</td>
    <td>RMP Input Link</td>
    <td>INLINK</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_limit">RLLS</a></td>
    <td>R</td>
    <td>Raw Low Limit Switch</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_link">RLNK</a></td>
    <td>R</td>
    <td>Readback OutLink</td>
    <td>OUTLINK</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_drive">RLV</a></td>
    <td>R/W*</td>
    <td>Relative Value</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_motion">RMOD</a></td>
    <td>R/W</td>
    <td>Retry Mode</td>
    <td>RECCHOICE</td>
    <td>(0:"Unity", 1:"Arthmetic", 2:"Geometric")<br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_status">RMP</a></td>
    <td>R</td>
    <td>Raw Motor Position</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_status">RRBV</a></td>
    <td>R</td>
    <td>Raw Readback Value</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_res">RRES</a></td>
    <td>R/W</td>
    <td>Readback Step Size (EGU)</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_motion">RTRY</a></td>
    <td>R/W</td>
    <td>Max retry count</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_drive">RVAL</a></td>
    <td>R/W*</td>
    <td>Raw Desired Value</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_status">RVEL</a></td>
    <td>R</td>
    <td>Raw Velocity</td>
    <td>LONG</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_motion">S</a></td>
    <td>R/W</td>
    <td>Speed (RPS)</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_motion">SBAK</a></td>
    <td>R/W</td>
    <td>BL Speed (RPS)</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_motion">SBAS</a></td>
    <td>R/W</td>
    <td>Base Speed (RPS)</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_calib">SET</a></td>
    <td>R/W</td>
    <td>Set/Use Switch</td>
    <td>RECCHOICE</td>
    <td>(0:"Use", 1:"Set")</td>
  </tr>
  <tr>
    <td><a href="#Fields_motion">SMAX</a></td>
    <td>R/W</td>
    <td>Max Velocity (RPS)</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_command">SPMG</a></td>
    <td>R/W*</td>
    <td>Stop/Pause/Move/Go</td>
    <td>RECCHOICE</td>
    <td>(0:"Stop", 1:"Pause", 2:"Move", 3:"Go")</td>
  </tr>
  <tr>
    <td><a href="#Fields_res">SREV</a></td>
    <td>R/W*</td>
    <td>Steps per Revolution</td>
    <td>LONG</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_calib">SSET</a></td>
    <td>R/W</td>
    <td>Set SET Mode</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_link">STOO</a></td>
    <td>R/W</td>
    <td>STOP OutLink</td>
    <td>OUTLINK</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_command">STOP</a></td>
    <td>R/W*</td>
    <td>Stop</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_status">STUP</a></td>
    <td>R</td>
    <td>Status Update Request</td>
    <td>RECCHOICE</td>
    <td>ON(1)<br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_calib">SUSE</a></td>
    <td>R/W</td>
    <td>Set USE Mode</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_status">TDIR</a></td>
    <td>R</td>
    <td>Direction of Travel</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_command">TWF</a></td>
    <td>R/W*</td>
    <td>Tweak motor Forward</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_command">TWR</a></td>
    <td>R/W*</td>
    <td>Tweak motor Reverse</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_command">TWV</a></td>
    <td>R/W*</td>
    <td>Tweak Step Size (EGU)</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_res">UEIP</a></td>
    <td>R/W*</td>
    <td>Use Encoder If Present</td>
    <td>RECCHOICE</td>
    <td>(0:"No", 1:"Yes")</td>
  </tr>
  <tr>
    <td><a href="#Fields_res">UREV</a></td>
    <td>R/W*</td>
    <td>EGU's per Revolution</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_res">URIP</a></td>
    <td>R/W*</td>
    <td>Use RDBL Link If Present</td>
    <td>RECCHOICE</td>
    <td>(0:"No", 1:"Yes")</td>
  </tr>
  <tr>
    <td><a href="#Fields_drive">VAL</a></td>
    <td>R/W*</td>
    <td>User Desired Value</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_motion">VBAS</a></td>
    <td>R/W</td>
    <td>Base Velocity (EGU/s)</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_motion">VELO</a></td>
    <td>R/W</td>
    <td>Velocity (EGU/s)</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_misc">VERS</a></td>
    <td>R</td>
    <td>Code Version</td>
    <td>DOUBLE</td>
    <td>e.g., "1.95"</td>
  </tr>
  <tr>
    <td><a href="#Fields_motion">VMAX</a></td>
    <td>R/W</td>
    <td>Max Velocity (EGU/s)</td>
    <td>DOUBLE</td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td><a href="#Fields_calib">VOF</a></td>
    <td>R/W</td>
    <td>Variable Offset</td>
    <td>SHORT</td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td align="left" colspan="5">
      <table>
	<tbody>
	<tr>
	  <td colspan="3">Note: In the <b>Access</b> column above:</td>
	</tr>
	<tr valign="top">
	  <td>R</td>
	  <td>Read only</td>
	  <td><br>
	  </td>
	</tr>
	<tr valign="top">
	  <td>R/W</td>
	  <td>Read and write are allowed</td>
	</tr>
	<tr valign="top">
	  <td>R/W*</td>
	  <td>Read and write are allowed; write triggers record processing if the record's 
	  SCAN field is set to "Passive."</td>
	</tr>
	<tr valign="top">
	  <td>N</td>
	  <td>No access allowed</td>
	</tr>
	<tr valign="top">
	  <td>Note: In the <b>Prompt </b>column above:</td>
	</tr>
	<tr valign="top">
	  <td>EGU</td>
	  <td>Engineering Units</td>
	</tr>
	<tr valign="top">
	  <td>RPS</td>
	  <td>Revolutions Per Second</td>
	</tr>
  </tbody>
      </table>
    </td>
  </tr>

  </tbody>
</table>

<hr>
<table border="1" cellpadding="0">
  <caption>
    <a name="Fields_calib"></a> <h2>Calibration-related fields</h2>
  </caption>
  <tbody>
  <tr valign="top">
    <th>Name</th>
    <th>Access</th>
    <th>Prompt</th>
    <th>Data type</th>
    <th>Comments</th>
  </tr>
  <tr valign="top">
    <td>DIR</td>
    <td>R/W*</td>
    <td>User Direction</td>
    <td>RECCHOICE</td>
    <td>(0:"Pos", 1:"Neg")</td>
  </tr>
  <tr>
    <td colspan="5">User and dial values are related by the equation&nbsp; <br>
      <tt>userVAL = DialVAL * DIR + OFFset</tt> <br>
      This field is the "DIR" in the above equation.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td>OFF</td>
    <td>R/W</td>
    <td>User Offset (EGU)</td>
    <td>DOUBLE</td>
    <td>User and dial coordinates can differ by a sign (the DIR field) and an offset 
    (OFF), according to the following equation:&nbsp; <br>
      <tt>userVAL = DialVAL * DIR + OFFset</tt> <br>
      This field is "OFFset" in the above equation. It is not normally written to 
      directly by the user.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>FOFF</td>
    <td>R/W</td>
    <td>Offset-Freeze Switch</td>
    <td>RECCHOICE</td>
    <td>(0:"Variable", 1:"Frozen")</td>
  </tr>
  <tr valign="top">
    <td>VOF</td>
    <td>R/W</td>
    <td>Variable Offset</td>
    <td>SHORT</td>
    <td>Set Offset switch (FOFF) to "Variable".</td>
  </tr>
  <tr valign="top">
    <td>FOF</td>
    <td>R/W</td>
    <td>Freeze Offset</td>
    <td>SHORT</td>
    <td>Set Offset switch (FOFF) to "Frozen".</td>
  </tr>
  <tr>
    <td colspan="5">The user can cause the difference between user and dial 
    coordinates to remain fixed (i.e., the record will not change it, although the 
    user may) by setting FOFF to "Frozen." The fields VOF and FOF are intended for 
    use in backup/restore operations; any write to them will drive the FOFF field to 
      "Variable" (VOF) or "Frozen" (FOF).&nbsp;</td>
  </tr>
  <tr valign="top">
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td>SET</td>
    <td>R/W</td>
    <td>Set/Use Switch</td>
    <td>RECCHOICE</td>
    <td>(0:"Use", 1:"Set")</td>
  </tr>
  <tr valign="top">
    <td>SSET</td>
    <td>R/W</td>
    <td>Set SET Mode</td>
    <td>SHORT</td>
    <td>Set Set/Use switch to "Set".</td>
  </tr>
  <tr valign="top">
    <td>SUSE</td>
    <td>R/W</td>
    <td>Set USE Mode</td>
    <td>SHORT</td>
    <td>Set Set/Use switch to "Use".</td>
  </tr>
  <tr>
    <td colspan="5">SET is a toggle switch used in calibrating the motor's user and 
    dial positions:&nbsp;
      <p>
      When SET = 0 ("Use"), writes to the user-coordinate drive field (VAL) cause the 
      dial-coordinate drive field (DVAL) to change, and the motor to move. Writes to 
      the dial-coordinate drive field (DVAL) cause the user-coordinate drive field (VAL) 
      to change, and the motor to move.
      </p>

      <p>
      When SET = 1 ("Set"), writes to the dial-coordinate drive field (DVAL) and to 
      the raw drive field (RVAL) cause a new raw motor position to be loaded into the 
      hardware without any change to the user-coordinate drive  field (VAL). Writes to 
      other fields that would normally move the motor, change the user-coordinate 
      drive field (VAL), and the offset between user and dial coordinates (the OFF 
      field), with corresponding changes in the user-coordinate limit fields (HLM and 
      LLM). When the offset is frozen (FOFF=1), writes to any drive field affect both 
      user and dial values, and also load the hardware position register.
      </p>
    </td>
  </tr>
  <tr valign="top">
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>

  </tbody>
</table>

<hr>
<table border="1" cellpadding="5">
  <caption>
    <a name="Fields_res"></a> <h2>Motor-resolution fields</h2>
  </caption>
  <tbody>
  <tr valign="top">
    <th>Name</th>
    <th>Access</th>
    <th>Prompt</th>
    <th>Data type</th>
    <th>Comments</th>
  </tr>
  <tr valign="top">
    <td>MRES</td>
    <td>R/W*</td>
    <td>Motor Step Size (EGU)</td>
    <td>DOUBLE</td>
    <td>May be positive or negative</td>
  </tr>
  <tr valign="top">
    <td>SREV</td>
    <td>R/W*</td>
    <td>Steps per Revolution</td>
    <td>LONG</td>
    <td>Must be strictly positive</td>
  </tr>
  <tr valign="top">
    <td>UREV</td>
    <td>R/W*</td>
    <td>EGU's per Revolution</td>
    <td>DOUBLE</td>
    <td>May be positive or negative</td>
  </tr>
  <tr>
    <td colspan="5">MRES, and (SREV,UREV) represent two ways of specifying the motor 
    resolution--the distance or angle, in engineering units (EGU's), associated with 
    a single motor step. The equation relating these quantities is "MRES = UREV/SREV 
    ". Initially, SREV has the value 200, the number of full steps per revolution 
    for most stepper motors, and the record never changes this field. Only the user 
    can change it.&nbsp;
      <p>
      When MRES is changed, the motor record sets UREV = MRES*SREV. When UREV or SREV 
      is changed, the motor sets MRES = UREV/SREV. In all cases, the effect of a motor 
      resolution change on the reported motor position depends in a simple way on the 
      value of the SET field: <br>
      If (SET = 1), new user and dial values (VAL, DVAL) are calculated from the 
      existing raw value (RVAL). <br>
      If (SET = 0), a new raw value is calculated from the existing dial value. <br>
      The motor doesn't move in either case; neither does the actual motor speed (in 
      revolutions per second) change.&nbsp;
      </p>

      <p>
      If either MRES or UREV is changed, motor speeds that are expressed in 
      engineering units per second (i.e., those whose names contain the letter 'V': 
      VELO, BVEL, VMAX and VBAS) are automatically adjusted by the motor record 
      according to the following equations: VELO = UREV * S; BVEL = UREV * SBAK; VMAX 
      = UREV * SMAX; VBAS = UREV * SBAS.&nbsp; Motor speeds that are expressed in 
      revolutions per second (S, SBAK, and SBAS) are independent of changes to MRES or 
      UREV.&nbsp; In contrast, when SREV is changed, only MRES is adjusted by the 
      motor record, thus allowing all other fields to remain unaffected.
      </p>

      <p>
      Currently, changes to motor-resolution fields have no effect on the values of 
      limit fields (although they should).&nbsp;
      </p>

      <p>
      MRES or UREV allow negative values so that the user/dial coordinate systems can 
      be configured to the opposite polarity of the motor controller's.
      </p>
    </td>
  </tr>
  <tr valign="top">
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td>ERES</td>
    <td>R/W*</td>
    <td>Encoder Step Size (EGU)</td>
    <td>DOUBLE</td>
    <TD>
      Encoder resolution: the distance or angle, in engineering units, associated 
      with a single encoder step. ERES may be positive or negative. If the user sets 
      ERES to zero, the record will overwrite it with MRES.
    </TD>
  </tr>
  <tr valign="top">
    <td>RRES</td>
    <td>R/W</td>
    <td>Readback Step Size (EGU)</td>
    <td>DOUBLE</td>
    <td>Readback-device resolution: the distance or angle, in engineering units,
    associated with a unit change of the number retrieved via the readback- location 
    input link (RDBL). RRES may be either positive or negative.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td>UEIP</td>
    <td>R/W*</td>
    <td>Use Encoder If Present</td>
    <td>RECCHOICE (0:"No", 1:"Yes")</td>
    <td>Switch: nonzero value tells the record to read the encoder (if the hardware 
    indicates an encoder is present) and to ignore the value read back from the 
    hardware's step-count register.&nbsp;
      <p>
      The state of the UEIP, together with the MSTA encoder indicator, determine:
      </p>

      <ol>
	<li>
	  if the RRBV is set to either the feedback (REP) or the command (RMP) position.
	</li>
	<li>
	  whether absolute or relative position commands are used.
	</li>

      </ol>
    </td>
  </tr>
  <tr valign="top">
    <td>URIP</td>
    <td>R/W*</td>
    <td>Use RDBL Link If Present</td>
    <td>RECCHOICE (0:"No", 1:"Yes")</td>
    <TD>Switch: nonzero value tells the record to get the motor position from the 
    readback-location link (RDBL) (if it contains valid EPICS link information, and 
    if no error occurs in the attempt to read from the link) and to ignore values 
    read back from the hardware's step-count and encoder registers.  If the RDBL 
    link is invalid or a read attempt results in an error, the motor position 
    becomes frozen.</TD>
  </tr>
  <tr>
    <td colspan="5">These switches also direct the record to calculate destinations 
    in relative, rather than absolute, terms, since the ratio of encoder and 
    readback units to motor steps may not actually be constant.</td>
  </tr>

  </tbody>
</table>

<hr>
<table border="1" cellpadding="5" nosave="">
  <caption>
    <a name="Fields_motion"></a> <h2>Motion-related fields</h2>
  </caption>
  <tbody>
  <tr valign="top">
    <th>Name</th>
    <th>Access</th>
    <th>Prompt</th>
    <th>Data type</th>
    <th>Comments</th>
  </tr>
  <tr>
    <td>VMAX</td>
    <td>R/W</td>
    <td>Max Velocity (EGU/s)</td>
    <td>DOUBLE</td>
    <td>Valid range; 0 &lt;= VMAX.&nbsp; VMAX=0 disables maximum velocity range
    checking.</td>
  </tr>
  <tr>
    <td>SMAX</td>
    <td>R/W</td>
    <td>Max Velocity (RPS)</td>
    <td>DOUBLE</td>
    <td>Valid range; 0 &lt;= SMAX</td>
  </tr>
  <tr>
    <td>VBAS</td>
    <td>R/W</td>
    <td>Base Velocity (EGU/s)</td>
    <td>DOUBLE</td>
    <td>Valid range; 0 &lt;= VBAS</td>
  </tr>
  <tr>
    <td>SBAS</td>
    <td>R/W</td>
    <td>Base Speed (RPS)</td>
    <td>DOUBLE</td>
    <td>Valid range; 0 &lt;= SBAS</td>
  </tr>
  <tr nosave="">
    <td colspan="5" nosave="">Range checking is done in such a way that any minimum 
    (i.e., VBAS/SBAS) or maximum (i.e., VMAX/SMAX) value entered is valid.&nbsp; For 
    example, if the minimum is entered and it exceeds the maximum, then the maximum 
    is set to the new minimum value.&nbsp; A VMAX value of zero disables maximum 
    velocity range checking.
      <p>
      At boot-up, if one field of a field pair (i.e., VMAX/SMAX, VBAS/SBAS, VELO/S, 
      BVEL/SBAK) is zero and the other field is nonzero, the nonzero field takes 
      precedence.&nbsp; If both fields of a given field pair are nonzero, the RPS 
      member of the field pair (i.e., SMAX, SBAS, S, SBAK) takes precedence.
      </p>

      <p>
      Slew (VELO/S) and backup (BVEL/SBAK) velocity fields are silently forced by the 
      motor record to be within the range set by VMAX/SMAX and VBAS/SBAS, inclusively.
      </p>

      <p>
      Those who use both BURT and VMAX (i.e., nonzero VMAX) should insure that VMAX 
      and VBAS are placed before VELO and BVEL in their BURT request files.
      </p>

      <p>
      The intent of VBAS/SBAS is to prevent the motor from moving at speeds slow 
      enough to excite its resonance, which can cause the motor to miss steps. The 
      motor is expected to accelerate from a stand-still to VBAS in one motor pulse.&nbsp;
      </p>
    </td>
  </tr>
  <tr valign="top">
    <td>VELO</td>
    <td>R/W</td>
    <td>Velocity (EGU/s)</td>
    <td>DOUBLE</td>
    <td>Valid range; VBAS &lt;= VELO &lt;= VMAX</td>
  </tr>
  <tr valign="top">
    <td>S</td>
    <td>R/W</td>
    <td>Speed (RPS)</td>
    <td>DOUBLE</td>
    <td>Valid range;&nbsp; SBAS &lt;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    &lt;= SMAX</td>
  </tr>
  <tr>
    <td colspan="5">VELO is the speed, in engineering units per second, at which the 
    motor is moved after the acceleration phase of a motion is finished. S is the 
    same speed expressed in revolutions per second. The record makes sure that VELO 
    and S are consistent, using the equation S = VELO/UREV.</td>
  </tr>
  <tr>
    <td>HVEL</td>
    <td>R/W</td>
    <td>Velocity (EGU/s)</td>
    <td>DOUBLE</td>
    <td>Homing velocity; valid range; VBAS &lt;= HVEL &lt;= VMAX</td>
  </tr>
  <tr valign="top">
    <td>ACCL</td>
    <td>R/W</td>
    <td>Seconds to Velocity</td>
    <td>DOUBLE</td>
    <td>The length, in seconds, of the acceleration and deceleration phases of a 
    motor motion.</td>
  </tr>
  <tr>
    <td colspan="5">The motor record expects the hardware to produce a trapezoidal 
    speed profile. That is, the motor speed is expected to increase linearly with 
    time from the base speed, VBAS, to the full speed, VELO, in ACCL seconds. At the 
    end of a motion, the speed is expected to decrease similarly to VBAS.&nbsp;</td>
  </tr>
  <tr>
    <td>JVEL</td>
    <td>R/W</td>
    <td>Jog Velocity (EGU/s)</td>
    <td>DOUBLE</td>
    <td>Valid range; VBAS &lt;= VELO &lt;= VMAX</td>
  </tr>
  <tr>
    <td>JAR</td>
    <td>R/W</td>
    <td>Jog Acceleration (EGU/s^2)</td>
    <td>DOUBLE</td>
    <td>Default value: VELO / ACCL</td>
  </tr>
  <tr nosave="">
    <td colspan="5" nosave="">With the OMS and IMS device drivers, jog velocity can 
    be changed on-the-fly.&nbsp; The velocity will accelerate to the new velocity 
    based on the JAR field.</td>
  </tr>
  <tr valign="top">
    <td>BDST</td>
    <td>R/W</td>
    <td>BL Distance (EGU)</td>
    <td>DOUBLE</td>
    <td>The signed distance, in dial coordinates, used for backlash takeout.</td>
  </tr>
  <tr>
    <td colspan="5">The algorithm used in moves to a (dial-coordinate) position 
    called "TARGET" follows:&nbsp;
      <p>
      1) If the motor is to move a distance greater than the magnitude of BDST, or if 
      the motor is to move in a direction opposite to the sign of BDST, then the motor 
      will move first to position (TARGET-BDST), at an acceleration specified by ACCL 
      and speed VELO, and then to position TARGET, at an acceleration specified by 
      BACC and speed BVEL.&nbsp;
      </p>

      <p>
      2) If the motor is to move a distance smaller than the magnitude of BDST, and if 
      the motor is to move in the same direction as the sign of BDST, then backlash is 
      assumed already to have been taken out, and the motor will move to position 
      TARGET at an acceleration specified by BACC and speed BVEL.&nbsp;
      </p>
    </td>
  </tr>
  <tr valign="top">
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td>BVEL</td>
    <td>R/W</td>
    <td>BL Velocity (EGU/s)</td>
    <td>DOUBLE</td>
  </tr>
  <tr valign="top">
    <td>SBAK</td>
    <td>R/W</td>
    <td>BL Speed (RPS)</td>
    <td>DOUBLE</td>
  </tr>
  <tr>
    <td colspan="5">BVEL is the speed, in engineering units per second, at which the 
    motor is move after the acceleration phase of a backlash-takeout motion is 
    finished. SBAK is the same speed expressed in revolutions per second. Neither 
    BVEL nor SBAK may be negative or zero.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td>BACC</td>
    <td>R/W</td>
    <td>BL Seconds to Veloc.</td>
    <td>DOUBLE</td>
    <td>The length, in seconds, of the acceleration and deceleration phases of a 
    backlash-takeout motion. See discussion of the acceleration field ACCL for more 
    specific information.</td>
  </tr>
  <tr valign="top">
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td>FRAC</td>
    <td>R/W</td>
    <td>Move Fraction</td>
    <td>DOUBLE</td>
  </tr>
  <tr>
    <td colspan="5">This field supports closed-loop control of pathological devices 
    for which drive values are not expected to compare reproducibly with readback 
    values. (Inchworms and other friction-driven devices are good examples: the 
    number of steps taken by an inchworm motor is a very poor indicator of the 
    distance it has traveled.)&nbsp;
      <p>
      In a move from position CURRENT to position TARGET, the motor record will ask 
      hardware to move a distance FRAC*(TARGET-CURRENT). When that motion is complete, 
      the record will request a motion of FRAC*(remaining distance), and so on until 
      the target position has been reached.&nbsp;
      </p>
    </td>
  </tr>
  <tr valign="top">
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td>RDBD</td>
    <td>R/W</td>
    <td>Retry Deadband (EGU)</td>
    <td>DOUBLE</td>
    <td>When the motor has finished a complete motion, possibly including backlash
    takeout, the motor record will compare its current position with the desired
    position. If the magnitude of the difference is greater than RDBD, the motor
    will try again, as if the user had requested a move from the now current
    position to the desired position. Only a limited number of retries will be
    performed (see RTRY).&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>RTRY</td>
    <td>R/W</td>
    <td>Max retry count</td>
    <td>SHORT</td>
    <td>The maximum number of times the motor record will try again to move to the 
    desired position. When the retry limit is reached, the motor record will declare 
    the motion finished. If the desired position was not reached, the field MISS 
    will be set to 1.</td>
  </tr>
  <tr valign="top">
    <td>RMOD</td>
    <td>R/W</td>
    <td>Retry Mode</td>
    <td>RECCHOICE</td>
    <td>
      <p>
      (0:"Unity", 1:"Arthmetic", 2:"Geometric")
      </p>
      <p>
      RMOD allows the user to select different ways of calculating the retry distance 
      move.  The default mode (Unity) moves the motor a relative distance based on 
      the dial error (DIFF field). Badly behaved devices (piezo motors) can oscillate 
      around their target position in this mode.  Hence, two other modes were added to 
      allow a decreasing response from the motor record after each retry.
      </p>
      <p>
      The Arithmetic mode generates an arithmetic sequence of corrections. For example, 
      if the max. retry count (RTRY) is 10, then the retries will proceed as follows; 
      DIFF * (1.0), DIFF * (9/10), DIFF * (8/10), etc.
      </p>
      <p>
      The Geometric mode generates a geometric sequence with a 1/2 common factor of 
      corrections.  For example, if the max. retry count is 10, then the retries will 
      proceed as follows; DIFF * (1.0), DIFF * (1/2) DIFF * (1/4), DIFF * (1/8), etc.
      </p>
    </td>
  </tr>
  </tbody>
</table>

<hr>
<table border="1" cellpadding="5" nosave="">
  <caption>
    <a name="Fields_link"></a> <h2>Link-related fields</h2>
  </caption>
  <tbody>
  <tr valign="top">
    <th>Name</th>
    <th>Access</th>
    <th>Prompt</th>
    <th>Data type</th>
    <th>Comments</th>
  </tr>
  <tr valign="top">
    <td>OUT</td>
    <td>R/W</td>
    <td>Output Specification</td>
    <td>OUTLINK</td>
    <td>If Soft Channel device support is specified, this field is an EPICS link; 
    each time DVAL is changed, device support puts DVAL to this link.&nbsp; 
    Otherwise, this field specifies the hardware to be controlled.</td>
  </tr>
  <tr valign="top">
    <td>RDBL</td>
    <td>R</td>
    <td>Readback Location</td>
    <td>INLINK</td>
    <td>This field specifies the field (of this or any other EPICS record) from 
    which the motor's current position is to be read when the field URIP (Use 
    Readback If Present) has the value "Yes" (1). If this field does not contain a 
    valid EPICS link, the URIP may as well have the value "No" (0).&nbsp; If Soft 
    Channel device support is specified, this field is monitored for value changes 
    by a CA event task.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>DOL</td>
    <td>R</td>
    <td>Desired Output Loc</td>
    <td>INLINK</td>
    <td>If this field contains a valid EPICS link, and the OMSL field has the  value 
      "closed_loop" (1), then every time the motor record is processed, it will 
      get a value for the VAL field from the link and move to that location, ignoring 
      all other drive fields. Closed-loop mode has not been tested extensively.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>OMSL</td>
    <td>R/W</td>
    <td>Output Mode Select</td>
    <td>GBLCHOICE</td>
    <td>(0:"supervisory", 1:"closed_loop")&nbsp; <br>
      If this field has the value "closed_loop" (1), and the field DOL contains a 
      valid EPICS link, then every time the motor record is processed, it will get 
      a value for the VAL field from the link and move to that location, ignoring all 
      other drive fields. Closed-loop mode has not been tested extensively.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>RLNK</td>
    <td>R</td>
    <td>Readback OutLink</td>
    <td>OUTLINK</td>
    <td>If this field contains a valid EPICS link, then every time the motor record 
    is processed, it will put the (engineering-unit) readback value RBV to that link.&nbsp;</td>
  </tr>
  <tr>
    <td>DINP</td>
    <td>R/W</td>
    <td>DMOV Input Link</td>
    <td>INLINK</td>
    <td>If Soft Channel device support is specified, the value specified by this 
    link is used to set the DONE bit in the MSTA field; which in turn sets the DMOV 
    field.</td>
  </tr>
  <tr>
    <td>RINP</td>
    <td>R/W</td>
    <td>RMP Input Link</td>
    <td>INLINK</td>
    <td>If Soft Channel device support is specified, the value specified by this 
    link is used to set the RMP field.</td>
  </tr>
  <tr>
    <td>STOO</td>
    <td>R/W</td>
    <td>STOP OutLink</td>
    <td>OUTLINK</td>
    <td>If Soft Channel device support is specified, a one is written to the&nbsp; 
    specified link each time the STOP_AXIS motor command is issued.</td>
  </tr>
  <TR nosave="">
    <TD colspan="5" nosave=""><H4>Soft Channel Device Driver</H4>
      The Soft Channel database links (i.e., DINP, RINP and STOO) are only processed 
      when the Soft Channel device driver is selected.&nbsp; These links are ignored 
      when using any other Motor Record device driver. <BR>
      <BR>
      The input links (i.e., DINP, RDBL and RINP) are monitored for value changes by a 
      CA event task.&nbsp; Users must choose either a dial input link (RDBL) or a raw 
      input link (RINP), but not both. At this time, the above links are <B>not</B> 
      dynamically retargetable.&nbsp; <BR>
      <BR>
      Note that Soft Channel device support resets the target position (VAL/DVAL/RVAL) 
      to the actual position (RBV/DRBV/RRBV) the first time, and only the first time, 
      that the PV pointed to by RDBL is posted. Hence, Soft Channel device support 
      requires that the RDBL PV have a valid value the first time it is posted.&nbsp; <BR>
      <BR>
      Note that JOG[F/R] does not work with the Soft Channel device driver.
    </TD>
  </TR>

  </tbody>
</table>

<hr>
<table border="1" cellpadding="5">
  <caption>
    <a name="Fields_limit"></a> <h2>Limit-related fields</h2>
  </caption>
  <tbody>
  <tr valign="top">
    <th>Name</th>
    <th>Access</th>
    <th>Prompt</th>
    <th>Data type</th>
    <th>Comments</th>
  </tr>
  <tr valign="top">
    <td>HLM</td>
    <td>R/W*</td>
    <td>User High Limit</td>
    <td>DOUBLE</td>
    <td>The maximum allowed value of the VAL field. If HLM changes so that VAL is no 
    longer less than HLM, then the record will set the field LVIO to 1. If the DIR 
    field has the value "Pos", then HLM will always be consistent with DHLM, 
    otherwise HLM will always be consistent with DLLM.</td>
  </tr>
  <tr valign="top">
    <td>LLM</td>
    <td>R/W*</td>
    <td>User Low Limit</td>
    <td>DOUBLE</td>
    <td>The minimum allowed value of the VAL field. If LLM changes so that VAL is no 
    longer greater than LLM, then the record will set the field LVIO to 1. If the 
    DIR field has the value "Pos", then LLM will always be consistent with DLLM, 
    otherwise LLM will always be consistent with DHLM.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>DHLM</td>
    <td>R/W*</td>
    <td>Dial High Limit</td>
    <td>DOUBLE</td>
    <td>The maximum allowed value of the DVAL field. If DHLM changes so that DVAL is 
    no longer less than DHLM, then the record will set the field LVIO to 1.. If the 
    DIR field has the value "Pos", then DHLM will always be consistent with HLM, 
    otherwise DHLM will always be consistent with LLM.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>DLLM</td>
    <td>R/W*</td>
    <td>Dial Low Limit</td>
    <td>DOUBLE</td>
    <td>The minimum allowed value of the DVAL field. If DLLM changes so that DVAL is 
    no longer greater than DLLM, then the record will set the field LVIO to 1. If 
    the DIR field has the value "Pos", then DLLM will always be consistent with LLM, 
    otherwise DLLM will always be consistent with HLM.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>LVIO</td>
    <td>R</td>
    <td>Limit violation</td>
    <td>SHORT</td>
    <td>A value of 1 indicates that the dial-value drive field, DVAL, or the dial-value 
    readback field, DRBV, is outside of the limits (DHLM, DLLM), and this prevents 
    the motor from moving. If the backlash distance, BDST, is non-zero, it further 
    restricts the allowable range of DVAL. When a JOG button is hit, LVIO goes to 1 
    and stops the motor if/when DVAL gets to within one second's travel time of 
    either limit.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>PERL</td>
    <td>R/W</td>
    <td>Periodic Limits</td>
    <td>RECCHOICE</td>
    <td>(0:"No", 1:"Yes") <br>
      Not implemented. Originally intended to support periodic "limits" on the VAL 
      field (such as those associated with a rotation stage--e.g., [0...360] or [-180...180]) 
      independently of the actual soft limits HLM and LLM.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>HOPR</td>
    <td>R/W</td>
    <td>High Operating Range</td>
    <td>DOUBLE</td>
    <td>Not used. See HLM and DHLM.</td>
  </tr>
  <tr valign="top">
    <td>LOPR</td>
    <td>R/W</td>
    <td>Low Operating Range</td>
    <td>DOUBLE</td>
    <td>Not used. See LLM and DLLM.</td>
  </tr>
  <tr valign="top">
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td>HLS</td>
    <td>R</td>
    <td>At High Limit Switch</td>
    <td>SHORT</td>
  </tr>
  <tr valign="top">
    <td>RHLS</td>
    <td>R</td>
    <td>Raw High Limit Switch</td>
    <td>SHORT</td>
  </tr>
  <tr>
    <td colspan="5">If either of these fields is nonzero, then the motor is at the 
    positive-limit switch, where the positive sense is that of the user-coordinate 
    system for HLS, and that of the raw (step-number) coordinate system for RHLS.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td>LLS</td>
    <td>R</td>
    <td>At Low Limit Switch</td>
    <td>SHORT</td>
  </tr>
  <tr valign="top">
    <td>RLLS</td>
    <td>R</td>
    <td>Raw Low Limit Switch</td>
    <td>SHORT</td>
  </tr>
  <tr>
    <td colspan="5">If either of these fields is nonzero, then the motor is at the 
    negative-limit switch, where the positive sense is that of the user-coordinate 
    system for LLS, and that of the raw (step-number) coordinate system for RLLS.</td>
  </tr>
  <tr valign="top">
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>

  </tbody>
</table>

<hr>
<table border="1" cellpadding="5">
  <caption>
    <a name="Fields_command"></a> <h2>Command-button fields</h2>
  </caption>
  <tbody>
  <tr valign="top">
    <th>Name</th>
    <th>Access</th>
    <th>Prompt</th>
    <th>Data type</th>
    <th>Comments</th>
  </tr>
  <tr valign="top">
    <td>SPMG</td>
    <td>R/W*</td>
    <td>Stop/Pause/Move/Go</td>
    <td>RECCHOICE</td>
    <td>(0:"Stop", 1:"Pause", 2:"Move", 3:"Go")</td>
  </tr>
  <tr>
    <td colspan="5">This field is intended primarily for interactive use, and 
    normally has the value "Go."&nbsp;
      <p>
      If the user sets this field to "Stop," the motor will decelerate to a stop, the 
      VAL field will be set equal to the RBV field, and the DVAL field will be set 
      equal to the DRBV field. (These actions ensure that the motor will not start 
      moving again until a drive field is changed.) In any case, the motor will not 
      move while SPMG has the value "Stop" or "Pause."&nbsp;
      </p>

      <p>
      If "SPMG" has the value "Move," the motor record will reset SPMG to "Pause" when 
      a motion completes. This behavior supports users who want a motor to sit still 
      until they say "Move", no matter what changes occur in the drive fields.&nbsp;
      </p>
    </td>
  </tr>
  <tr valign="top">
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td>STOP</td>
    <td>R/W*</td>
    <td>Stop</td>
    <td>SHORT</td>
  </tr>
  <tr>
    <td colspan="5">When this field is set to 1, the record will immediately reset 
    it to 0, and the motor will decelerate to a stop. When the motor has stopped, 
    VAL will be set equal to RBV, and DVAL will be set equal to DRBV. (This ensures 
    that the motor will not start moving the next time the record is processed, 
    unless a drive field is explicitly changed. If you want the motor to pause, use 
    the SPMG field.)&nbsp;</td>
  </tr>
  <tr valign="top">
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td>HOMF</td>
    <td>R/W*</td>
    <td>Home Forward</td>
    <td>SHORT</td>
  </tr>
  <tr valign="top">
    <td>HOMR</td>
    <td>R/W*</td>
    <td>Home Reverse</td>
    <td>SHORT</td>
  </tr>
  <tr>
    <td colspan="5">When one of these fields is set to 1, the motor will decelerate 
    to a stop if already moving, move in the indicated direction (in <i>dial</i> 
    coordinates) at the acceleration specified by ACCL and a speed specified by HVEL, 
    until the hardware detects the "home" switch has become active. Then the 
    hardware will do something hardware dependent in response to its "home" command, 
    if any. (The OMS hardware causes the motor to decelerate to a stop.) When the 
    motor stops, the VAL field will be set equal to the RBV field, and the DVAL 
    field will be set equal to the DRBV field.&nbsp; These fields can be set to 1, 
    but setting either field to 0 results in an error.&nbsp; The record sets HOM[F/R] 
    to zero when the homing procedure is either completed or aborted.</td>
  </tr>
  <tr valign="top">
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td>JOGF</td>
    <td>R/W*</td>
    <td>Jog motor Forward</td>
    <td>SHORT</td>
  </tr>
  <tr valign="top">
    <td>JOGR</td>
    <td>R/W*</td>
    <td>Jog motor Reverse</td>
    <td>SHORT</td>
  </tr>
  <tr>
    <td colspan="5">When one of these fields is set to 1, the motor will decelerate 
    to a stop if already moving, and move in the indicated direction (in user 
    coordinates) at an acceleration specified by ACCL and speed VELO, until the 
    field goes to 0. Then the motor will set VAL to RBV and DVAL to DRBV, decelerate 
    to a stop, and execute a (backlash-corrected, if BDST is nonzero) move to the 
    position at which the field went to 0.&nbsp;
      <p>
      These fields are dangerous when used over channel access, because the motor does 
      not stop moving until a second message is received. If a very busy network 
      should cause that second message to be lost, the motor will travel to its limit 
      switch or hard stop.&nbsp;
      </p>
    </td>
  </tr>
  <tr valign="top">
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td>TWF</td>
    <td>R/W*</td>
    <td>Tweak motor Forward</td>
    <td>SHORT</td>
  </tr>
  <tr valign="top">
    <td>TWR</td>
    <td>R/W*</td>
    <td>Tweak motor Reverse</td>
    <td>SHORT</td>
  </tr>
  <tr>
    <td colspan="5">When one of these fields is set to 1, the record will 
    immediately reset it to 0, and the motor will move (with backlash takeout if 
    BDST is nonzero) by a distance TWV (in user coordinates) at the acceleration 
    specified by ACCL and at speed VELO.</td>
  </tr>
  <tr valign="top">
    <td>TWV</td>
    <td>R/W*</td>
    <td>Tweak Step Size (EGU)</td>
    <td>DOUBLE</td>
    <td>This field contains the distance the motor is to move in response to  the 
    TWF and TWR buttons.</td>
  </tr>

  </tbody>
</table>

<hr>
<table border="1" cellpadding="5">
  <caption>
    <a name="Fields_drive"></a> <h2>Drive fields</h2>
  </caption>
  <tbody>
  <tr valign="top">
    <th>Name</th>
    <th>Access</th>
    <th>Prompt</th>
    <th>Data type</th>
    <th>Comments</th>
  </tr>
  <tr valign="top">
    <td>VAL</td>
    <td>R/W*</td>
    <td>User Desired Value</td>
    <td>DOUBLE</td>
    <td>This is the desired position in user coordinates. When this field is written
    to, DVAL and RVAL will be changed correspondingly, and the motor will move (with
    backlash takeout if BDST is nonzero) to the newly written position.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>DVAL</td>
    <td>R/W*</td>
    <td>Dial Desired Value</td>
    <td>DOUBLE</td>
    <td>This is the desired position in dial coordinates. When this field is written
    to, VAL and RVAL will be changed correspondingly, and the motor will move (with
    backlash takeout if BDST is nonzero) to the newly written position.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>RVAL</td>
    <td>R/W*</td>
    <td>Raw Desired Value</td>
    <td>DOUBLE</td>
    <td>This is the desired position in raw coordinates. When this field is written 
    to, VAL and DVAL will be changed correspondingly, and the motor will move (with 
    backlash takeout if BDST is nonzero) to the newly written position.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>RLV</td>
    <td>R/W*</td>
    <td>Relative Value</td>
    <td>DOUBLE</td>
    <td>When this field is changed, its value will be added to VAL, the field itself 
    will immediately be reset to 0, and the motor record will behave as though the 
    VAL field had been changed directly.&nbsp;</td>
  </tr>

  </tbody>
</table>

<hr>
<table border="1" cellpadding="5">
  <caption>
    <a name="Fields_status"></a> <h2>Status/readback fields</h2>
  </caption>
  <tbody>
  <tr valign="top">
    <th>Name</th>
    <th>Access</th>
    <th>Prompt</th>
    <th>Data type</th>
    <th>Comments</th>
  </tr>
  <tr valign="top">
    <td>RBV</td>
    <td>R</td>
    <td>User Readback Value</td>
    <td>DOUBLE</td>
    <td>The current motor position, in user coordinates, from the motor hardware (default), 
    or from the encoder supported by the motor-controller hardware (if UEIP is 
    nonzero), or from the readback link RDBL (if URIP is nonzero).&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>DRBV</td>
    <td>R</td>
    <td>Dial Readback Value</td>
    <td>DOUBLE</td>
    <td>The current motor position, in dial coordinates, from the motor hardware (default), 
    or from the encoder supported by the motor-controller hardware (if UEIP is 
    nonzero), or from the readback link RDBL (if URIP is nonzero).&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>DMOV</td>
    <td>R</td>
    <td>Done moving to value</td>
    <td>SHORT</td>
  </tr>
  <tr>
    <td colspan="5">This field is set to 0 when the motor record begins a motion, 
    and remains 0 through any retries and backlash corrections that may be required 
    until the motor record has completely finished that motion, whereupon the field 
    is set to 1. DMOV is guaranteed to execute and post a 1/0/1 pulse when the motor 
    is commanded to move--even if no motion actually occurs because the motor was 
    commanded to move to its current position.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>MOVN</td>
    <td>R</td>
    <td>Motor is moving</td>
    <td>SHORT</td>
    <td>This field is set to 1 while the record believes that the motor actually is 
    moving. This field is not the inverse of DMOV, since it may go to zero during a 
    complex motion, if that motion includes a momentary stop.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>DLY</td>
    <td>R/W</td>
    <td>Readback settle time (s)</td>
    <td>DOUBLE</td>
    <td>Delay (in seconds) the time between motor controller done and motor record 
    done (i.e., DMOV).</td>
  </tr>
  <tr valign="top">
    <td>DIFF</td>
    <td>R</td>
    <td>Difference dval-drbv</td>
    <td>DOUBLE</td>
    <td rowspan="2">DIFF is the difference, in engineering units, between the
    desired motor position, and the readback device's report of the current position. 
    RDIF is the same difference in "raw" units (normally, steps).&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>RDIF</td>
    <td>R</td>
    <td>Difference rval-rrbv</td>
    <td>LONG</td>
  </tr>
  <tr valign="top">
    <td>RRBV</td>
    <td>R</td>
    <td>Raw Readback Value</td>
    <td>DOUBLE</td>
    <td>The current position of the motor, encoder, or readback link, as received 
    from whatever source has been selected to provide position information. The 
    units associated with this field depend on the source.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>RMP</td>
    <td>R</td>
    <td>Raw Motor Position</td>
    <td>DOUBLE</td>
    <td>The contents of the hardware's step-count register. This field contains the 
    same information as the dial value, but in steps, rather than in engineering 
    units.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>REP</td>
    <td>R</td>
    <td>Raw Encoder Position</td>
    <td>DOUBLE</td>
    <td>The contents of the hardware's encoder-count register. Ideally, this field 
    contains the same information as the dial value, but in encoder counts, rather 
    than in engineering units.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>MSTA</td>
    <td>R</td>
    <td>Motor Status</td>
    <td>ULONG</td>
    <td>The motor status as received from the hardware.&nbsp; The MSTA bits are 
    defined as follows:
      <blockquote>
	<ol>
	  <li>
	    DIRECTION: last raw direction; (0:Negative, 1:Positive)
	  </li>
	  <li>
	    DONE: motion is complete.
	  </li>
	  <li>
	    PLUS_LS: plus limit switch has been hit.
	  </li>
	  <li>
	    HOMELS: state of the home limit switch.
	  </li>
	  <li>
	    Unused
	  </li>
	  <li>
	    POSITION: closed-loop position control is enabled.
	  </li>
	  <li>
	    SLIP_STALL: Slip/Stall detected (eg. fatal following error)
	  </li>
	  <li>
	    HOME: if at home position.
	  </li>
	  <li>
	    PRESENT: encoder is present.
	  </li>
	  <li>
	    PROBLEM: driver stopped polling, or hardware problem
	  </li>
	  <li>
	    MOVING: non-zero velocity present.
	  </li>
	  <li>
	    GAIN_SUPPORT: motor supports closed-loop position control.
	  </li>
	  <li>
	    COMM_ERR: Controller communication error.
	  </li>
	  <li>
	    MINUS_LS: minus limit switch has been hit.
	  </li>
	  <li>
	    HOMED: the motor has been homed.<br>
	  </li>
	</ol>
	The record is put into MAJOR STATE alarm if either SLIP_STALL or PROBLEM bits are detected. 
	If HLSV is set, then the record is put into HIGH alarm if either a high soft limit or 
	hard limit (PLUS_LS) has been reached. Similary for the low limits.
      </blockquote>
    </td>
  </tr>
  <tr valign="top">
    <td>TDIR</td>
    <td>R</td>
    <td>Direction of Travel</td>
    <td>SHORT</td>
    <td>The direction in which the motor is currently traveling (or was most 
    recently traveling), as received from the hardware. If 0, the raw readback value 
    should be decreasing.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>ATHM</td>
    <td>R</td>
    <td>At HOME</td>
    <td>SHORT</td>
    <td>The state of the hardware's "home" switch. If 1, the motor has hit the 
    switch.</td>
  </tr>
  <tr valign="top">
    <td>RCNT</td>
    <td>R</td>
    <td>Retry count</td>
    <td>SHORT</td>
    <td>The number of times the motor record has detected failure of the motor to 
    land within the retry-deadband distance of the desired position.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>MISS</td>
    <td>R</td>
    <td>Ran out of retries</td>
    <td>SHORT</td>
    <td>If 1, the motor has failed to land on the desired position more than the 
    allowed number of times. This field will be reset the next time the motor 
    succeeds in reaching the desired position.&nbsp;</td>
  </tr>
  <tr valign="top">
    <td>RVEL</td>
    <td>R</td>
    <td>Raw Velocity</td>
    <td>LONG</td>
    <td>Speed in steps per second that the motor actually is moving.</td>
  </tr>
  <tr valign="top">
    <td>STUP</td>
    <td>R/W</td>
    <td>Status Update</td>
    <td>RECCHOICE</td>
    <td>
      The STUP field functions as follows;
      <ul>
	<LI>
	  Valid values for STUP are OFF(0), ON(1) and BUSY(2).
	</LI>
	<LI>
	  A Channel Access (CA) client writes ON(1) to the STUP field which causes the 
	  motor record to set STUP to BUSY(2) and request a single controller status 
	  update.  After the status is updated the record sets STUP to OFF(0).
	</LI>
	<LI>
	  CA clients are restricted to writing ON(1) to STUP only when STUP is OFF(0).
	</LI>
    
	<LI>
	  It is the responsibility of the user to restrict the frequency (and thus the 
	  incurred overhead) at which the CA client writes ON(1) to STUP.
	</LI>
      </UL>
      <P>
      With the STUP field it is possible to have another EPICS record periodically 
      write ON(1) to the motor record's STUP field.  This would result in continuous, 
      periodic status updates.
      </P>
    </td>
  </tr>

  </tbody>
</table>

<hr>
<center>
  <p>
  <a name="Servo_fields"></a>
  </p>
</center>

<center>
  <h2>Servo fields</h2>
</center>

<table border="1" cellpadding="5" nosave="">
  <caption>
    &nbsp;
  </caption>
  <tbody>
  <tr nosave="">
    <td colspan="5" nosave="">PID related record fields accept only normalized 
    values (i.e., 0.0 &lt;= value &lt;= 1.0).&nbsp; Before sending them to the motor 
    controller, device support scales the record fields to valid motor controller 
    parameters,.&nbsp; Let the motor controller PID parameters be represented by CKP, 
    CKI and CKD; then the PID coefficients are converted from motor record fields to 
    controller parameters as follows:
      <p>
      For the MM4000;&nbsp; CKP = PCOF, CKI = ICOF and CKD = DCOF. <br>
      For all OMS controllers;&nbsp; CKP = 1999.9 * PCOF, CKI = 1999.9 * ICOF, CKD = 
      1999.9 * DCOF. 
      </p>

      <p>
      Note the following: 
      </p>

      <ul>
	<li>
	  When commanded to move the OMS control law is a PD loop, when it is holding a 
	  position it is a PID loop.
	</li>
	<li>
	  The Proportional Gain cannot be turned off (i.e., set to zero) in an OMS 
	  controller.&nbsp; The minimum value is PCOF = 0.00005 (CKP = 0.1).&nbsp; If the 
	  user sets PCOF &lt; 0.00005 for an OMS controller, device support silently 
	  resets it to it's minimum value of 0.00005.
	</li>

      </ul>
    </td>
  </tr>
  <tr>
    <td>
      <center>
	<b>Name</b>
      </center>
    </td>
    <td>
      <center>
	<b>Access</b>
      </center>
    </td>
    <td>
      <center>
	<b>Prompt</b>
      </center>
    </td>
    <td>
      <center>
	<b>Data type</b>
      </center>
    </td>
    <td>
      <center>
	<b>Comments</b>
      </center>
    </td>
  </tr>
  <tr>
    <td>CNEN</td>
    <td>R/W</td>
    <td>Enable control</td>
    <td>RECCHOICE</td>
    <td>(0:"Disable", 1:"Enable")&nbsp; Enable/Disable closed-loop position control.&nbsp; 
    This field is active only if the GAIN_SUPPORT bit in the MSTA is true.&nbsp; 
    This field is set by both the user and device support.&nbsp; CNEN is set to <i>Disable</i> 
    by device support when it detects a motion controller error; e.g. maximum 
    following error exceeded.</td>
  </tr>
  <tr valign="top">
    <td>PCOF</td>
    <td>R/W</td>
    <td>Proportional Gain</td>
    <td>DOUBLE</td>
    <td>Valid range; 0.0 &lt;= PCOF &lt;= 1.0</td>
  </tr>
  <tr valign="top">
    <td>&nbsp;ICOF</td>
    <td>R/W</td>
    <td>Integral Gain</td>
    <td>DOUBLE</td>
    <td>Valid range; 0.0 &lt;= ICOF &lt;= 1.0</td>
  </tr>
  <tr valign="top">
    <td>&nbsp;DCOF</td>
    <td>R/W</td>
    <td>Derivative Gain</td>
    <td>DOUBLE</td>
    <td>Valid range; 0.0 &lt;= DCOF &lt;= 1.0</td>
  </tr>

  </tbody>
</table>
<br>
&nbsp;
<table border="1" cellpadding="5">
  <caption>
    <center>
      <p>
      <a name="Fields_alarm"></a>
      </p>
    </center>

    <center>
      <h2>Alarm fields</h2>
    </center>
  </caption>
  <tbody>
  <tr valign="top">
    <th>Name</th>
    <th>Access</th>
    <th>Prompt</th>
    <th>Data type</th>
    <th>Comments</th>
  </tr>
  <tr valign="top">
    <td>HIHI</td>
    <td>R/W*</td>
    <td>Hihi Alarm Limit</td>
    <td>DOUBLE</td>
  </tr>
  <tr valign="top">
    <td>LOLO</td>
    <td>R/W*</td>
    <td>Lolo Alarm Limit</td>
    <td>DOUBLE</td>
  </tr>
  <tr valign="top">
    <td>HIGH</td>
    <td>R/W*</td>
    <td>High Alarm Limit</td>
    <td>DOUBLE</td>
  </tr>
  <tr valign="top">
    <td>LOW</td>
    <td>R/W*</td>
    <td>Low Alarm Limit</td>
    <td>DOUBLE</td>
  </tr>
  <tr valign="top">
    <td>HHSV</td>
    <td>R/W*</td>
    <td>Hihi Severity</td>
    <td>GBLCHOICE</td>
    <td>Not used.</td>
  </tr>
  <tr valign="top">
    <td>LLSV</td>
    <td>R/W*</td>
    <td>Lolo Severity</td>
    <td>GBLCHOICE</td>
    <td>Not used.</td>
  </tr>
  <tr valign="top">
    <td>HSV</td>
    <td>R/W*</td>
    <td>High Severity</td>
    <td>GBLCHOICE</td>
    <td>Not used.</td>
  </tr>
  <tr valign="top">
    <td>LSV</td>
    <td>R/W*</td>
    <td>Low Severity</td>
    <td>GBLCHOICE</td>
    <td>Not used.</td>
  </tr>
  <tr valign="top">
    <td>HLSV</td>
    <td>R/W*</td>
    <td>HW Limit Switch Violation Severity</td>
    <td>GBLCHOICE</td>
  </tr>

  </tbody>
</table>

<hr>
<table border="1" cellpadding="5" nosave="">
  <caption>
    <a name="Fields_misc"></a> <h2>Miscellaneous fields</h2>
  </caption>
  <tbody>
  <tr valign="top">
    <th>Name</th>
    <th>Access</th>
    <th>Prompt</th>
    <th>Data type</th>
    <th>Comments</th>
  </tr>
  <tr valign="top">
    <td>PREC</td>
    <td>R/W</td>
    <td>Display Precision</td>
    <td>SHORT</td>
    <td>The number of digits to the right of the decimal that are to be displayed by 
    MEDM and other channel-access clients.</td>
  </tr>
  <tr valign="top">
    <td>EGU</td>
    <td>R/W</td>
    <td>Engineering Units</td>
    <td>STRING</td>
    <td>String sent to channel-access clients who ask for engineering units.</td>
  </tr>
  <tr valign="top">
    <td>VERS</td>
    <td>R</td>
    <td>Code Version</td>
    <td>DOUBLE</td>
    <td>Version number of the recMotor.c code.</td>
  </tr>
  <tr valign="top">
    <td>CARD</td>
    <td>R</td>
    <td>Card Number</td>
    <td>SHORT</td>
    <td>For VME based devices (i.e., OMS VME8/44, OMS VME58 and V544) this is the 
    VME card number, derived from the output link. Cards are numbered from zero 
    according to their VME addresses.&nbsp; Oregon Micro Systems series VME8 and 
    VME44 cards occur in the same series, since they are handled by the same driver.&nbsp; 
    Oregon Micro Systems VME58 cards are numbered separately, as are Highland 
    Technology V540 cards.&nbsp; This field is set to -1 for non-VME based device/drivers.</td>
  </tr>
  <tr nosave="">
    <td colspan="5" nosave=""><h4>Command Primitives</h4> The following three fields 
    comprise the Command Primitives feature.&nbsp; The command primitive record 
    fields are available to the user to send ASCII command primitives to the motor 
    control board at fixed, predefined, times.&nbsp; Each of the fields is defined 
    as a character string.&nbsp; Consult the motor controller manual for command 
    protocols.&nbsp; No error checking is done by the motor record or the device 
    driver to insure that the command strings are valid.&nbsp; Each field is <i>terminated</i> 
    by the device driver according to the command protocol.&nbsp; Command primitives 
    that result in a response from the motion control board are valid, but the 
    response is not processed.&nbsp; This feature is currently only available with 
    OMS VME8/44/58 or Newport MM4000 device support.
      <p>
      <b>Device Directives</b>
      </p>

      <ul>
	<li>
	  Valid only in the INIT, PREM and POST fields.
	</li>
	<li>
	  Must be identified by the following;
	</li>

	<blockquote>
	  <li>
	    First character of a device directive string must be a '@'.
	  </li>
	  <li>
	    One or more characters followed by a terminating '@'; i.e., device directives 
	    must have nonzero length.
	  </li>
	  <li>
	    Valid device directives:
	  </li>
	  <blockquote>
	    <li>
	      In the INIT field; only "DPM_ON".
	    </li>
	    <li>
	      In the PREM field;, only "PUT(<i>pvname</i>, <i>pv-value</i>, <i>delay in 
	      seconds</i>)".
	    </li>
	    <li>
	      In the POST field; only "PUT(<i>pvname</i>, <i>pv-value</i>)".
	    </li>
	  </blockquote>
          See <i>Driver Power Monitoring</i> below for the DPM_ON directive. &nbsp;The PUT 
          directive supports changing the value of a database variable. &nbsp;Note that 
          the PREM supports a time delay argument before the motor move , but that POST 
          does not. &nbsp;The <i>Readback settle time field</i> (DLY) should be used to 
          create a time delay after the PV specified in the POST field is written.
	</blockquote>
	<li>
	  Device directive strings are stripped of valid device directives (including @'s) 
	  and tested for nonzero length before being sent to the controller.&nbsp; For 
	  example, given the INIT string, "@DPM_ON@HE", the device directive @DPM_ON@ is 
	  stripped out before HE is sent to the controller.
	</li>
      </ul>
      <b>Driver Power Monitoring</b>
      <ul>
	<li>
	  This feature is only available with the OMS VME58 device support.
	</li>
	<li>
	  The 8 User I/O signals are assigned to the 8 possible VME58 axes as follows:
	</li>

	<ul>
	  <tt><font size="+1">User I/O #0 &lt;&gt; X axis</font></tt> <br>
	  <tt><font size="+1">&nbsp;"&nbsp;&nbsp; "&nbsp;&nbsp;&nbsp; 1 &lt;&gt; Y&nbsp; "</font></tt>
	  <br>
	  <tt><font size="+1">........................................</font></tt> <br>
	  <tt><font size="+1">"&nbsp;&nbsp;&nbsp; "&nbsp;&nbsp;&nbsp; 7 &lt;&gt; S&nbsp; "</font></tt>
	</ul>
	<li>
	  Drive-power monitoring defaults to disabled at boot-up.&nbsp; Request enabling 
	  drive-power monitoring by entering the device directive "@DPM_ON@" command into 
	  the motor record initialization field (i.e., INIT).&nbsp; The INIT field is 
	  processed at record initialization (i.e., bootup), hence if there are no errors, 
	  drive-power monitoring will be enabled after the next bootup.
	</li>
	<li>
	  Whenever a request is made to enable drive-power status monitoring, an error 
	  check is made (using the VME58 "RB" command) to verify that the User I/O has 
	  been configured as an input.&nbsp; The following message will appear in the 
	  error log if a configuration error is detected; "Invalid VME58 configuration; RB 
	  = 0x####", where "####" is the VME58's response to the RB command.
	</li>
	<li>
	  When drive-power status monitoring is enabled and a power failure is detected, 
	  the device driver will respond by activating the RA_OVERTRAVEL bit in the 
	  MSTA.&nbsp; This results in either HLS or LLS being activated depending on the 
	  DIR field. In addition, the following message will appear in the error log; "Drive 
	  power failure at VME58 card#?? motor#??".
	</li>

      </ul>
    </td>
  </tr>
  <tr>
    <td>INIT</td>
    <td>R/W</td>
    <td>Startup commands</td>
    <td>STRING</td>
    <td>Sent at record initialization.</td>
  </tr>
  <tr>
    <td>PREM</td>
    <td>R/W</td>
    <td>Pre-move commands</td>
    <td>STRING</td>
    <td>Sent before every command string that causes motion.</td>
  </tr>
  <tr>
    <td>POST</td>
    <td>R/W</td>
    <td>Post-move commands</td>
    <td>STRING</td>
    <td>Sent after a complete motion is finished or when an overtravel limit switch 
    is detected.</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>LOCK</td>
    <td>R/W</td>
    <td>Soft Channel Position Lock</td>
    <td>RECCHOICE</td>
    <td>After a "hard" motor initiated move, Soft Channel device support 
    automatically synchronizes a "soft" motor's target position with a "hard" motor's 
    readback position.  Soft Channel device support detects that the "hard" motor 
    has initiated the move when it sees the PV pointed to by DINP go false, while 
    the "soft" record's DMOV is true. Automatic synchronization is undesirable in a 
    multi-axis application. Hence, setting the LOCK field to "YES" disables this 
    automatic synchronization.</td>
  </tr>
  <tr>
    <td>NTM</td>
    <td>R/W</td>
    <td>New Target Monitor</td>
    <td>RECCHOICE</td>
    <td>The requirements on how the motor record processes a new target position 
    while the motor is in motion are as follows;<BR>
      Case #1: The motor record is given a new position, which is in the opposite 
      direction from the current motor motion.  If NTM is "YES", the motor is 
      immediately stopped and given a motion command to the new position.  If NTM is "NO 
      ", the motor completes the previous move before it is given a motion command to 
      the new position.<BR>
      Case #2: The motor record is given a new position, which is in the same 
      direction as the current motor motion, but the new position is closer to the 
      motor's current position than the original target position.  If NTM is "YES", 
      the motor is stopped after it has gone past the new position; then a command is 
      given to return to the new position.  If NTM is "NO", the motor completes the 
      previous move before it is given a motion command to the new position.<BR>
      Case #3: The motor record is given a new position, which is in the same 
      direction as the current motor motion, but the new position is further from the 
      motor's current position than the original position.  After the motor reaches 
      the original target position and stops, a command is given to the new target 
      position.  This case is independent of NTM.<BR>
      NTM defaults to "YES".  It should be set to "NO" only for soft motors. Soft 
      motors should be configured with NTM set to "NO" to prevent Case #1 above from 
      interfering with "hard" motors using backlash correction.  </td>
  </tr>
  <tr>
    <td>NTMF</td>
    <td>R/W</td>
    <td>New Target Monitor Deadband Factor</td>
    <td>SHORT</td>
    <td>Determines NTM deadband = NTMF * (|BDST| + RDBD).  NTMF must be >= 2.  The 
    NTM deadband prevents NTM logic from issuing a STOP command at the end of a DC 
    motor move that overshoots its' target position.</td>
  </tr>
  </tbody>
</table>

<hr>
<table border="1" cellpadding="5">
  <caption>
    <a name="Fields_private"></a> <h2>Private fields</h2>
  </caption>
  <tbody>
  <tr valign="top">
    <th>Name</th>
    <th>Access</th>
    <th>Prompt</th>
    <th>Data type</th>
    <th>Comments</th>
  </tr>
  <tr>
    <td>CBAK</td>
    <td>None</td>
    <td>Callback structure</td>
    <td>NOACCESS</td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td>LVAL</td>
    <td>R</td>
    <td>Last User Des Val</td>
    <td>DOUBLE</td>
  </tr>
  <tr valign="top">
    <td>LDVL</td>
    <td>R</td>
    <td>Last Dial Des Val</td>
    <td>DOUBLE</td>
  </tr>
  <tr valign="top">
    <td>LRVL</td>
    <td>R</td>
    <td>Last Raw Des Val</td>
    <td>DOUBLE</td>
  </tr>
  <tr valign="top">
    <td>LRLV</td>
    <td>R</td>
    <td>Last Rel Value</td>
    <td>DOUBLE</td>
  </tr>
  <tr>
    <td>CDIR<br>
    </td>
    <td>R</td>
    <td>Raw commanded direction<br>
    </td>
    <td>SHORT<br>
    </td>
  </tr>
  <tr valign="top">
    <td>PP</td>
    <td>R</td>
    <td>Post process command</td>
    <td>SHORT</td>
  </tr>
  <tr valign="top">
    <td>MIP</td>
    <td>R</td>
    <td>Motion In Progress</td>
    <td>SHORT</td>
  </tr>
  <tr valign="top">
    <td>MMAP</td>
    <td>R</td>
    <td>Monitor Mask</td>
    <td>ULONG</td>
  </tr>
  <tr valign="top">
    <td>NMAP</td>
    <td>R</td>
    <td>Monitor Mask</td>
    <td>ULONG</td>
  </tr>
  <tr valign="top">
    <td>LSPG</td>
    <td>R</td>
    <td>Last SPMG</td>
    <td>RECCHOICE</td>
    <td>(see SPMG)</td>
  </tr>

  </tbody>
</table>

<hr>
<p>
<a name="Files"></a>
</p>

<h2>Files, device support</h2> The following table briefly describes all of the 
files required to implement and use the motor record. The reader is assumed to 
be familiar with the <a href="http://www.aps.anl.gov/asd/controls/epics/EpicsDocumentation/WWWPages/EpicsDocs/AppDevManuals/AppSrcRelControl/AppSRControl.html">EPICS 
Application Source/Release Control document</a> which describes how to build an 
EPICS application tree into which these files are to be placed, and how to run
"makesdr" and "gnumake" to build the record support. These files can all be
obtained from the <a href="http://www.aps.anl.gov/xfd/WWW/xfd/SoftDist/Welcome.html">EPICS 
Software Distribution</a> (in the <a href="http://www.aps.anl.gov/xfd/WWW/xfd/SoftDist/Welcome.html#Custom_EPICS">custom-software 
section</a> ).
<table border="1" cellpadding="5">
  <tbody>
  <tr>
    <th colspan="2">SOURCE CODE <br>
      files to be placed in <tt>&amp;lttop&gt;/&amp;ltapp&amp;gtApp/src/</tt></th>
  </tr>
  <tr valign="top">
    <td>motorRecord.dbd</td>
    <td>Database Definition file for motor record.</td>
  </tr>
  <tr>
    <td>motorRecord.c&nbsp;</td>
    <td>Record support for the motor record</td>
  </tr>
  <tr valign="top">
    <td>motor.h&nbsp;</td>
    <td>Header included by all .c files</td>
  </tr>
  <tr>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td>motordevCom.c</td>
    <td>Device support common to all motor Record device drivers.</td>
  </tr>
  <tr>
    <td>motordevCom.h</td>
    <td>Device support header file.</td>
  </tr>
  <tr>
    <td>motordrvCom.c</td>
    <td>Driver support common to all motor Record device drivers.</td>
  </tr>
  <tr>
    <td>motordrvCom.h</td>
    <td>Driver support header file.</td>
  </tr>
  <tr>
    <td>motordrvComCode.h</td>
    <td>Local variables common to all motor Record drivers.</td>
  </tr>
  <tr>
    <td><br>
    </td>
    <td>NOTE: All of the above files are required for any and all motor Record 
    device drivers.</td>
  </tr>
  <tr>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td>devOmsCom.c</td>
    <td>Device support common to all Oregon Micro Systems device drivers.</td>
  </tr>
  <tr>
    <td>devOmsCom.h</td>
    <td>Device support header file common to all Oregon Micro Systems device drivers.</td>
  </tr>
  <tr>
    <td>drvOmsCom.h</td>
    <td>Driver support header file common to all Oregon Micro Systems device drivers.</td>
  </tr>
  <tr>
    <td><br>
    </td>
    <td>NOTE: The above files are required for any and all Oregon Micro Systems 
    device drivers.</td>
  </tr>
  <tr>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td>devOms.c</td>
    <td>Device support for Oregon Micro Systems VME8 and VME44 series boards</td>
  </tr>
  <tr valign="top">
    <td>drvOms.c</td>
    <td>Driver for Oregon Micro Systems VME8 and VME44 series boards</td>
  </tr>
  <tr valign="top">
    <td>drvOms.h</td>
    <td>Header included by devOms.c and drvOms.c</td>
  </tr>
  <tr>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td>devOms58.c</td>
    <td>Device support for Oregon Micro Systems VME58 series boards</td>
  </tr>
  <tr valign="top">
    <td>drvOms58.c</td>
    <td>Driver for Oregon Micro Systems VME58 series boards</td>
  </tr>
  <tr valign="top">
    <td>drvOms58.h</td>
    <td>Header included by devOms58.c and drvOms58.c</td>
  </tr>
  <tr>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr valign="top">
    <td>devV544.c</td>
    <td>Device support for Highland Technology boards.</td>
  </tr>
  <tr valign="top">
    <td>drvV544.c</td>
    <td>Driver for Highland Technology boards.</td>
  </tr>
  <tr valign="top">
    <td>drvV544.h</td>
    <td>Header included by devV544.c and drvV544.c</td>
  </tr>
  <tr>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td>drvMMCom.h</td>
    <td>Common header included by all Newport Motion Master device drivers.</td>
  </tr>
  <tr>
    <td><br>
    </td>
    <td>NOTE: The above files are required for any and all Newport Motion Master
    device drivers.</td>
  </tr>
  <tr>
    <td>devMM3000.c</td>
    <td>Device support for Newport MM3000.</td>
  </tr>
  <tr>
    <td>drvMM3000.c</td>
    <td>Driver for Newport MM3000.</td>
  </tr>
  <tr>
    <td>devMM4000.c</td>
    <td>Device support for Newport MM4000/40005.</td>
  </tr>
  <tr>
    <td>drvMM4000.c</td>
    <td>Driver for Newport MM4000/40005.</td>
  </tr>
  <tr>
    <td>devPM500.c</td>
    <td>Device support for Newport PM500.</td>
  </tr>
  <tr>
    <td>drvPM500.c</td>
    <td>Driver for Newport PM500.</td>
  </tr>
  <tr>
    <td>devESP300.c<br>
    </td>
    <td>Device support for Newport ESP300.</td>
  </tr>
  <tr>
    <td valign="top">drvESP300.c<br>
    </td>
    <td>Driver for Newport ESP300.</td>
  </tr>
  <tr>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td>devSoft.c</td>
    <td>Soft Channel device support.</td>
  </tr>
  <tr>
    <td>devSoftAux.c</td>
    <td>Soft Channel device support (Note: CA and record access code cannot both 
    reside in the same file; each defines (redefines) the DBR's.&nbsp; Hence, 
    functions are split between this and the above file base on whether they are 
    record oriented (devSoft.c) or CA oriented (devSoftAux.c).</td>
  </tr>
  <tr>
    <td>devSoft.h</td>
    <td>Header included by devSoft.c and devSoftAux.c</td>
  </tr>
  <tr>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td>gpibIO.h</td>
    <td>GPIB communication include file.</td>
  </tr>
  <tr>
    <td>gpibIO.c</td>
    <td>GPIB interface via Hideos.</td>
  </tr>
  <tr>
    <td>serialIO.h</td>
    <td>Serial communication include file.</td>
  </tr>
  <tr>
    <td>serialIOMPF.cc</td>
    <td>Serial communication interface via MPF.</td>
  </tr>
  <tr>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  <tr>
    <td>drvIM483.h</td>
    <td>Common header included by all IMS device drivers.</td>
  </tr>
  <tr>
    <td>devIM483PL.c</td>
    <td>Device support for IM483 in <i>party line</i> communication mode.</td>
  </tr>
  <tr>
    <td>devIM483SM.c</td>
    <td>Device support for IM483 in <i>single mode</i> communication mode.</td>
  </tr>
  <tr>
    <td>drvIM483PL.c</td>
    <td>Driver for IM483 in <i>party line</i> communication mode.</td>
  </tr>
  <tr>
    <td>drvIM483SM.c</td>
    <td>Driver for IM483 in <i>single mode </i>communication mode.</td>
  </tr>
  <tr>
    <td><br>
    </td>
    <td><br>
    </td>
  </tr>
  </tbody>
</table>

<table border="1" cellpadding="5">
  <tbody>
  <tr>
    <th colspan="2">MEDM DISPLAY SCREENS <br>
      files to be placed in <tt>&amp;lttop&gt;/&amp;ltapp&amp;gtApp/op/adl/</tt></th>
  </tr>
  <tr valign="top">
    <td>motorx.adl</td>
    <td>Small motor-control screen</td>
  </tr>
  <tr valign="top">
    <td>motorx_tiny.adl&nbsp;</td>
    <td>Tiny motor-control screen</td>
  </tr>
  <tr valign="top">
    <td>motorx_more.adl&nbsp;</td>
    <td>Medium motor-control screen</td>
  </tr>
  <tr valign="top">
    <td>motorx_setup.adl</td>
    <td>Setup screen for a single motor</td>
  </tr>
  <tr valign="top">
    <td>motorx_all.adl&nbsp;</td>
    <td>Debug screen for a single motor</td>
  </tr>
  <tr>
    <td colspan="2">These files build <tt>medm</tt> screens to access the motor 
    record. To use one of them from the command line, type, for example

      <pre>medm -x -macro "P=XXX:,M=m1" motorx.adl</pre>
      where <tt>XXX:m1</tt> is the name of a motor record in an IOC.

      <p>
      These files can also be used as related displays from other <tt>medm</tt> 
      screens by passing the argument <tt>"P=XXX:,M=m1"</tt> .
      </p>
    </td>
  </tr>

  </tbody>
</table>

<table border="1" cellpadding="5">
  <tbody>
  <tr>
    <th colspan="2"><br>
      EPICS STARTUP FILES <br>
      files to be placed in <tt>&amp;lttop&gt;/ioc/ioc&amp;ltname&gt;/</tt></th>
  </tr>
  <tr valign="top">
    <td>st.cmdmv167&nbsp;</td>
    <td>Startup script</td>
  </tr>
  <tr>
    <td colspan="2">A sample startup script, containing excerpts relevant to motors, 
    is included in the distribution. Here is an annotated copy:

      <pre>#######################################################################<br>
      # vxWorks startup script to load and execute system (iocCore) software.</pre>
      <b><font color="#ffffff">Load standard EPICS software</font></b>

      <pre># the following should be loaded first - BEGIN<br>ld &lt; targetmv167/
      iocCore<br>ld &lt; targetmv167/drvSup<br>ld &lt; targetmv167/devSup<br>ld &lt;
      targetmv167/recSup<br># the following should be loaded first - END</pre>
      <b><font color="#ffffff">Load custom EPICS software (including motor support)</font></b>

      <pre>ld &lt; ../../stdApp/src/O.mv167/stdlib.o</pre>
      <b><font color="#ffffff">Motor-related debug switches&nbsp;</font></b>

      <pre>recMotordebug = 0<br><br>#OMS vme8/vme44 debug switches<br>devOMSdebug = 0<br>
      drvOMSdebug = 0<br><br>#OMS vme58 debug switches<br>devOms58debug = 0<br>
      drvOms58debug = 0<br><br>#Highland Technology V544 debug switches<br>devV544ebug
      = 0<br>drvV544debug = 0</pre>
      <b><font color="#ffffff">Motor-related databases&nbsp;</font></b>

      <pre># load this before loading any databases<br>dbLoad "../../default.dctsdr"<br><br>
      #allstop<br>dbLoadRecords("../../stdApp/gDb/allstop.db","P=tmm:")<br>#motors<br>
      dbLoadRecords("../../stdApp/gDb/m16.db","P=tmm:")</pre>
      <b><font color="#ffffff">Specify motor-controller board address, interrupt 
      vector, etc.</font></b>
      <table border="1" cellpadding="5">
	<tbody>
	<TR>
	  <TD colspan="2"><TT>&nbsp; omsSetup(nCards, baseAddress, intVectBase, 
	  intLevel, pollRate)</TT> <BR>
	    <TT>oms58Setup(nCards, baseAddress, intVectBase, intLevel, pollRate)</TT> <BR>
	    <P>
	    <TT>MM3000Setup(nCards, pollRate)</TT> <BR>
	    <TT>MM3000Config(card#, portName, GPIB#)</TT>
	    </P>

	    <P>
	    <TT>MM4000Setup(nCards, pollRate)</TT> <BR>
	    <TT>MM4000Config(card#, portName, GPIB#)</TT>
	    </P>

	    <P>
	    <TT>IM483SMSetup(nCards, pollRate)&nbsp;</TT> <BR>
	    <TT>IM483SMConfig(card#, portName)&nbsp;</TT>

	    </P>

	    <P>
	    <TT>IM483PLSetup(nCommNet, pollRate)&nbsp;</TT> <BR>
	    <TT>IM483PLConfig(CommNet#, portName)&nbsp;</TT> <BR>
	    </P>

	    <P>
	    ESP300Setup(<TT>nCards, pollRate</TT>)<BR>
	    ESP300Config(<TT>card#, portName, GPIB#</TT>)<BR>
	    <BR>
	    <BR>
	    </P>
	  </TD>
	</TR>
	<tr valign="top">
	  <td>nCards</td>
	  <td>the number of cards or controllers; may be less, but not greater than this 
	  value.</td>
	</tr>
	<tr>
	  <td>nCommNet</td>
	  <td>the number of Communication networks&nbsp; (e.g., the number of RS-422 
	  networks for a IM483PL device).</td>
	</tr>
	<tr valign="top">
	  <td>baseAddress</td>
	  <td>the base address of the first card of a series. This must agree with address 
	  jumpers on the actual card(s).

	    <p>
	    OMS VME8, VME44, and VMEX cards are all of one series,  with a base address in 
	    the short address space, on a 16-byte (0x10) boundary. (I.e., these cards 
	    require 16 bytes each, and must all be addressed contiguously as, e.g., 0xFC00, 
	    0xFC10). 
	    </p>

	    <p>
	    OMS VME58-x cards are in their own series, also in the  short address space, on 
	    a 4k-byte (0x1000) boundary. 
	    </p>

	    <p>
	    Highland Technology V544 cards are in their own series,  in the short address 
	    space, on a 128-byte (0x80) boundary.
	    </p>
	  </td>
	</tr>
	<tr valign="top">
	  <td>intVectBase</td>
	  <td>the interrupt vector that will be loaded into the first card of a series.  
	  Succeeding cards will be loaded with intVectBase+1, intVectBase+2, etc. Set to "0 
	  " to disable interrupt generation; otherwise, stay in the range [64..255].</td>
	</tr>
	<tr valign="top">
	  <td>intLevel</td>
	  <td>the VME-interrupt level (in [1..6]) the cards will use. This must agree  
	  with jumper settings on the cards.</td>
	</tr>
	<tr valign="top">
	  <td>pollRate</td>
	  <td>the rate (in Hz.) at which the driver will interrogate a card when one of 
	  its motors is moving. This is also the rate at which channel-access monitors 
	  will be posted; to avoid saturating the network with motor-readback information, 
	  don't set pollRate much higher than 10 Hz. pollRate must be in the range [1..60].</td>
	</tr>
	<tr>
	  <td>portName</td>
	  <td>ASYN port name.</td>
	</tr>
	<tr>
	  <td valign="top">link<br>
	  </td>
	  <td valign="top">GPIB link or MPF server CPU location<br>
	  </td>
	</tr>
	<tr>
	  <td valign="top">GPIB#<br>
	  </td>
	  <td valign="top">GPIB address.<br>
	  </td>
	</tr>
        </tbody>
      </table>

      <P>
	# OMS VME8, VME44, VMEX driver setup parameters:<BR>omsSetup(5, 0xFC00, 180, 5, 
	10)<BR><BR># OMS VME58 driver setup parameters:<BR>oms58Setup(5, 0x2000, 190, 5, 
	10)
      </P>
      <P>#Start EPICS<BR>iocInit</P>
    </td>
  </tr>

  </tbody>
</table>

<table border="1" cellpadding="5">
  <tbody>
  <tr>
    <th colspan="2">BACKUP/RESTORE (BURT) REQUEST FILES <br>
      files to be placed in <tt>&amp;lttop&gt;/&amp;ltapp&amp;gtApp/op/burt/</tt></th>
  </tr>
  <tr valign="top">
    <td>settings.req</td>
    <td>sample request file to save settings of all motors. Edit this file, 
    supplying names of the motor records whose settings you want saved. (The sample 
    file also saves the states of other records in the sample database, m16.db, that 
    enable or disable the motor records.)</td>
  </tr>
  <tr valign="top">
    <td>yyMotorSettings.req&nbsp;</td>
    <td>save settings of a specified motor. This file is <tt>#include</tt> 'd  (once 
    for each motor) by settings.req.</td>
  </tr>
  <tr valign="top">
    <td>positions.req&nbsp;</td>
    <td>sample request file to save positions of all motors. Edit this file, 
    supplying names of the motor records whose positions you want saved.</td>
  </tr>
  <tr valign="top">
    <td>yyMotorPositions.req&nbsp;</td>
    <td>save position of a specified motor, This file is <tt>#include</tt> 'd  (once 
    for each motor) by positions.req.</td>
  </tr>
  <tr>
    <td colspan="2">These files tell the backup/restore tool how to save motor 
    settings and positions. To use them from the command line, type, for example

      <pre>burtrb -f settings.req -o myMotorSettings.snap<br><br>burtrb -f positions.
      req -o myMotorPositions.snap<br><br></pre>
      To restore the motor settings and positions saved by the above commands, type
      <pre>burtwb -f myMotorSettings.snap<br><br>burtwb -f myMotorPositions.snap<br><br></pre>
    </td>
  </tr>

  </tbody>
</table>

<hr>
<a name="Restrictions"></a> <h2>Restrictions</h2> You <i>must</i> not change the 
motor resolution while the motor is moving, but the record currently does not 
defend itself against this.
<p>
There is no way to ask for a reading of the motor's position register, encoder, 
or limit switches. These are read only while the motor is moving.
</p>

<p>
Because of the way limit-switch information is conveyed by the OMS hardware, the
motor record cannot know the states of both limit switches at the same time. It
only knows the state of the switch toward which the motor is moving.
</p>

<p>
If a move is requested while the motor already is in motion, the original move 
will still receive a (useless) backlash correction. 
</p>

<p>
Changing MRES (the motor resolution) should change VELO (the speed in 
engineering units per second), and leave S (the speed in revolutions per second) 
unchanged. Currently, neither VELO nor S appears to change, but the record 
behaves as though S had been changed to agree with VELO. A similar thing happens 
with SBAK and SBAS. <br>
</p>

<hr width="100%">
<br>
<a name="Examples"></a> <h2>Examples</h2>

<h4>Command Primitives</h4> This example assumes the controller is an MM4000 and 
that only one motor in the controller is moved at a time (MM4000 power on/off 
effects all motors).&nbsp; If the user wishes the system to perform as follows:
<ol>
  <li>
    Boot-up with motor power off.
  </li>
  <li>
    Turn motor power on before motor motion.
  </li>
  <li>
    Turn motor power off after motor motion.
  </li>

</ol>
Then set fields as follows:
<ul>
  <li>
    <tt><font size="+1">INIT = "MF"</font></tt>
  </li>
  <li>
    <tt><font size="+1">PREM = "MO"</font></tt>
  </li>
  <li>
    <tt><font size="+1">POST = "MF"</font></tt>
  </li>

</ul>

<h4>Soft Channel</h4> The following is a simple example of using soft channel 
device support to allow the user to transform rotary position commands into 
linear moves.&nbsp; This example assumes the system consist of a linear stage 
driving a tangent arm.&nbsp; The user commands the system in terms of the angle 
the arm makes with the vertical.&nbsp; The database converts this angle into a 
linear position along an axis that is one meter perpendicular to the center of 
rotation.

<p>
The following database implements the system described above.&nbsp; The database
consist of four records: 
</p>

<ul>
  <li>
    <u>rotary</u> - a <i>soft</i> motor record where the user issues angular 
    position commands in <i>degrees</i>.
  </li>
  <li>
    <u>convertDriveValue</u> - a <i>calcout</i> record that converts the commanded 
    position from <i>degrees</i> to <i>mm</i>.
  </li>
  <li>
    <u>linear</u> -&nbsp; a <i>hard </i>motor record using Oms58 device support that 
    accepts linear position commands in <i>mm.</i>
  </li>
  <li>
    <u>convertReadbackValue</u> - <i>calcout</i> record that converts the feedback 
    position from <i>mm </i>to <i>degrees</i>.
  </li>

</ul>
Note the following concerning the example database and Soft Channel device 
support:
<ul>
  <li>
    Jogging a soft channel motor record is <b>not</b> supported.
  </li>
  <li>
    In the <i>convertReadbackValue</i> record, CP is required in the INPA field to 
    get continuous readback updates to the <i>rotary</i> record.&nbsp; Otherwise, 
    the <i>rotary</i> record will only update at the end of a move.
  </li>
  <li>
    The <i>convertDriveValue</i> record converts <i>rotary's </i>DVAL field from 
    degrees to radians, takes the tangent, converts from meters to millimeters and 
    finally, sends this value to <i>linear's</i> DVAL field<i>.</i>
  </li>
  <li>
    The <i>convertReadbackValue</i> record converts <i>linear's</i> DRBV field from 
    millimeters to meters, takes the inverse tangent and finally, converts from 
    radians to degrees.
  </li>

</ul>

<table border="1" cols="2" width="100%" nosave="">
  <tbody>
  <tr valign="top" nosave="">
    <td nosave="">grecord(motor,"$(user):rotary") <br>
      { <br>
      &nbsp;&nbsp;&nbsp; field(DTYP,"Soft Channel") <br>
      &nbsp;&nbsp;&nbsp; field(OUT,"$(user):convertDriveValue.A&nbsp; PP MS") <br>
      &nbsp;&nbsp;&nbsp; field(RDBL,"$(user):convertReadbackValue.VAL&nbsp; NPP MS") <br>
      &nbsp;&nbsp;&nbsp; field(URIP,"Yes") <br>
      &nbsp;&nbsp;&nbsp; field(STOO,"$(user):linear.STOP&nbsp; PP MS") <br>
      &nbsp;&nbsp;&nbsp; field(DINP,"$(user):linear.DMOV&nbsp; NPP MS") <br>
      &nbsp;&nbsp;&nbsp; field(MRES,"0.001") <br>
      &nbsp;&nbsp;&nbsp; field(RRES,"1.000") <br>
      &nbsp;&nbsp;&nbsp; field(PREC,"3") <br>
      &nbsp;&nbsp;&nbsp; field(DHLM,"45") <br>
      &nbsp;&nbsp;&nbsp; field(DLLM,"-45") <br>
      &nbsp;&nbsp;&nbsp; field(TWV,"5") <br>
      &nbsp;&nbsp;&nbsp; field(RTRY,"0") <br>
      &nbsp;&nbsp;&nbsp; field(EGU,"deg.") <br>
      }</td>
    <td>grecord(motor,"$(user):linear") <br>
      { <br>
      &nbsp;&nbsp;&nbsp; field(DTYP,"OMS VME58") <br>
      &nbsp;&nbsp;&nbsp; field(VBAS,"1.0") <br>
      &nbsp;&nbsp;&nbsp; field(VELO,"25.0") <br>
      &nbsp;&nbsp;&nbsp; field(OUT,"#C0 S0 @") <br>
      &nbsp;&nbsp;&nbsp; field(MRES,"0.001") <br>
      &nbsp;&nbsp;&nbsp; field(PREC,"3") <br>
      &nbsp;&nbsp;&nbsp; field(DHLM,"1000") <br>
      &nbsp;&nbsp;&nbsp; field(DLLM,"-1000") <br>
      &nbsp;&nbsp;&nbsp; field(RTRY,"0") <br>
      &nbsp;&nbsp;&nbsp; field(TWV,"1") <br>
      &nbsp;&nbsp;&nbsp; field(EGU,"mm.") <br>
      }</td>
  </tr>
  <tr>
    <td>grecord(calcout,"$(user):convertDriveValue") <br>
      { <br>
      &nbsp;&nbsp;&nbsp; field(DESC,"Convert rotary to linear") <br>
      &nbsp;&nbsp;&nbsp; field(CALC,"TAN(A / 57.296) * 1000") <br>
      &nbsp;&nbsp;&nbsp; field(OUT,"$(user):linear.DVAL&nbsp; PP MS") <br>
      }</td>
    <td>grecord(calcout,"$(user):convertReadbackValue") <br>
      { <br>
      &nbsp;&nbsp;&nbsp; field(DESC,"Convert linear to rotary") <br>
      &nbsp;&nbsp;&nbsp; field(CALC,"ATAN(A / 1000) * 57.296") <br>
      &nbsp;&nbsp;&nbsp; field(INPA,"$(user):linear.DRBV&nbsp; CP MS") <br>
      }</td>
  </tr>

  </tbody>
</table>

<hr width="100%" size="2">
<a name="Design_Decisions"></a>

<h2>Design Decisions</h2> This section of the document is an attempt to record 
the reasoning behind recent motor record design decisions. <h4>Motor Controller 
Travel Limits</h4> For those motor controllers that provide their own internal 
software travel limits (e.g., MM4000), the motor record will only allow the user 
to set dial travel limits (i.e., D[H/L]LM) that are within the controller's 
travel limit range, inclusively.&nbsp; In making this design decision it was 
assumed that an <i>expert</i> user would enter the controller travel limits (possibly, 
through a front panel user interface) that would protect other users from 
reaching the hard travel limits.&nbsp; Controllers with their own travel limits 
that are commanded to move outside their valid range respond with an error.&nbsp; 
Hence, there is no utility in allowing the dial travel limits outside the 
controller's range. <h4>Separate EGU's and MRES's between Controller and Motor 
Record</h4> Device driver support for controllers that have characteristics 
different from the OMS controllers, such as the Newport MM4000, has raised new 
issues.&nbsp; One of these issues is whether or not the motor record should set 
it's EGU and MRES fields from the controller's values.&nbsp; We think it should 
not.

<p>
Background: The MM4000 is a stand-alone controller with it's own front panel, 
non-volatile memory and power supply.&nbsp; The user can configure the MM4000 
entirely from the front panel; including which engineering units will be 
displayed on the front panel.&nbsp; Once engineering units are selected, these 
same units will be used by the MM4000 when communicating with a host system (i.e., 
EPICS).&nbsp; Since a host can query the MM4000 for both the controller's 
engineering units and it's positioning resolution, it is possible to have the 
motor record's EGU and MRES fields automatically set based on values stored in 
the MM4000 controller, but we decided not to do this. 
</p>

<p>
To maximize flexibility, we decided to keep these characteristics separate 
between the motor record and the controller.&nbsp; This decision allows the 
motor record EGU field (and consequently, MRES) to be set to an application 
specific value (e.g., kV) that is not supported by the motor controller. <br>
&nbsp; <br>
&nbsp; 
</p>

<p>
</p>

<hr>
<address>Suggestions and comments to:</address> <br>
<a href="mailto:sluiter@aps.anl.gov">Ron Sluiter</a> : (sluiter@aps.anl.gov) <br>
<a href="mailto:mooney@aps.anl.gov">Tim Mooney</a> : (mooney@aps.anl.gov) <br>
<a href="mailto:sullivan@aps.anl.gov">Joe Sullivan</a> : (sullivan@aps.anl.gov) <br>
Last modified: June 25, 2003
</body>
</html>
