
#################################################################################
# General purpose Asyn motor template.
# Required macros: P, M, PORT, ADDR, DESC, VELO, MRES, PREC, EGU, DHLM, DLLM, TWV

record(motor,"$(P)$(M)")
{
	field(DESC,"$(DESC)")
	field(DTYP,"$(DTYP=asynMotor)")
	field(DIR,"$(DIR=0)")
	field(VELO,"$(VELO)")
	field(VBAS,"$(VBAS=0)")
	field(ACCL,"$(ACCL=0.5)")
	field(BDST,"$(BDST=0)")
	field(BVEL,"$(BVEL=0)")
	field(BACC,"$(BACC=0.5)")
	field(OUT,"@asyn($(PORT),$(ADDR))")
	field(MRES,"$(MRES)")
	field(PREC,"$(PREC)")
	field(EGU,"$(EGU)")
	field(DHLM,"$(DHLM)")
	field(DLLM,"$(DLLM)")
	field(INIT,"$(INIT=)")
	field(RTRY,"$(RTRY=0)")
        field(DLY,"$(DLY=0)")   
        field(HVEL,"$(HVEL=$(VELO))")
        field(SREV, "$(SREV=1000)")
        field(RRES, "$(RRES=)")
        field(TWV, "$(TWV)")
        field(ERES, "$(ERES=)")
        field(JAR, "$(JAR=)")
        field(UEIP, "$(UEIP=0)")
        field(URIP, "$(URIP=0)")        
        field(RDBL, "$(RDBL=)")         
        field(VMAX, "$(VMAX=$(VELO))")
        field(OFF, "$(OFF=0)")
        field(RDBD, "$(RDBD=)")
        field(FOFF, "$(FOFF=0)")
        field(ADEL, "$(ADEL=0)")
	field(MDEL, "$(MDEL=0)")
        field(NTM, "$(NTM=1)")
        field(HLSV, "$(HLSV=MAJOR)")
        field(SPDB, "$(SPDB=0)")
        field(SDIS, "$(P)$(M):SDIS.VAL") 
        #info(autosaveFields_pass0, "DVAL OFF MRES ERES")
	#info(autosaveFields, "DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL HVEL DESC SPDB")
	info(archive, "Monitor, 00:00:01, VAL OFF RBV DMOV MISS MSTA STAT LVIO HLS LLS RCNT MOVN CNEN SPDB DVAL")
}

#Enable/Disable channel access for the motor record
record(bo, "$(P)$(M):Disable") {
  field(VAL, "0")
  field(PINI, "YES")
  field(ZNAM, "Enabled")
  field(ONAM, "Disabled")
  info(autosaveFields_pass0, "VAL")
  field(OUT, "$(P)$(M):SDIS.A PP")
}

#Record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "$(P)$(M):SDIS") {
  field(DESC, "Disable on non-zero input")
  field(VAL, "0")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "$(P)$(M).DISP PP")
}

#Record to provide RMP scaling to engineering units
#Depending on UEIP we may not have this on RBV
record(calc, "$(P)$(M):MotorPos")
{
        field(DESC,"Motor Position")
        field(INPA,"$(P)$(M).RMP CP")
	field(INPB,"$(P)$(M).MRES NPP")
	field(CALC,"(A*B)")
	field(PREC,"$(PREC)")
	field(EGU, "$(EGU)")
        field(ADEL, "$(ADEL=0)")
	field(MDEL, "$(MDEL=0)")
	info(archive, "Monitor, 00:00:01, VAL")
}

#Record to provide REP scaling to engineering units
#Depending on UEIP we may not have this on RBV
record(calc, "$(P)$(M):EncoderPos")
{
        field(DESC,"Encoder Position")
        field(INPA,"$(P)$(M).REP CP")
	field(INPB,"$(P)$(M).ERES NPP")
	field(CALC,"(A*B)")
	field(PREC,"$(PREC)")
	field(EGU, "$(EGU)")
        field(ADEL, "$(ADEL=0)")
	field(MDEL, "$(MDEL=0)")
	info(archive, "Monitor, 00:00:01, VAL")	
}

#Record to calculate the following error
record(calc, "$(P)$(M):FERROR")
{
        field(DESC,"Following Error")
        field(INPA,"$(P)$(M).RMP CP")
        field(INPB,"$(P)$(M).REP CP")
        field(INPC,"$(P)$(M).MRES NPP")
        field(INPD,"$(P)$(M).ERES NPP")
        field(CALC,"ABS((A*C)-(B*D))")
        field(FLNK,"$(P)$(M):FERRORMAX")
        field(PREC,"$(PREC)")
        field(EGU, "$(EGU)")
        field(ADEL, "$(ADEL=0)")
	field(MDEL, "$(MDEL=0)")
        info(archive, "Monitor, 00:00:01, VAL")
}


#Record to store the maximum following error
record(calc, "$(P)$(M):FERRORMAX")
{
        field(DESC,"Following Error Max")
        field(INPA,"$(P)$(M):FERROR.VAL")
        field(INPB,"$(P)$(M):FERRORMAX.VAL")
        field(CALC,"(A>B)?A:B")
        field(HIGH,"$(FEHIGH=0)")
        field(HIHI,"$(FEHIHI=0)")
        field(HHSV,"$(FEHHSV=NO_ALARM)")
        field(HSV, "$(FEHSV=NO_ALARM)")
        field(PREC,"$(PREC)")
        field(EGU, "$(EGU)")
	info(autosaveFields, "VAL")
	info(archive, "Monitor, 00:00:10")
}       

#Record to reset the maximum following error
record(bo, "$(P)$(M):FEMAXRESET")
{
        field(DESC,"Reset max following error")
        field(DTYP,"Soft Channel")
        field(OUT, "$(P)$(M):FERRORMAX.VAL")
        field(VAL, "0")
}

#Manufacturers stated step angle given and issued pulse train specified at RES
record(ai, "$(P)$(M):ANG")
{
   field(DESC, "Angular motion")
   field(VAL, "1.8")
}

#Manufacturers stated step size for a motor revolution
record(ai, "$(P)$(M):RES")
{
   field(DESC, "Hardware step size")
   field(VAL, "200")
}

#Record to stop the motor record with ASG=ALWAYS
record(bo, "$(P)$(M):Stop")
{
        field(DESC,"Stop the motor")
        field(DTYP,"Soft Channel")
        field(OUT, "$(P)$(M).STOP PP")
        field(VAL, "1")
	field(ASG, "ALWAYS")
}

#Set this to non-zero if the driver should delay its done moving callbacks
#This has to be implemented in the driver axis poller function.
record(ao, "$(P)$(M):PostMoveDelay")
{
   field(DESC, "Post Move Delay")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_POST_MOVE_DELAY")
   field(VAL, "0")
   field(PINI, "YES")
   field(EGU, "s")
   field(PREC, "1")
   info(autosaveFields, "VAL")
}

#Include record to provide calculated error
include "error_calc.db"

#Include records to control the visibility of the home buttons on motor_detail.db
include "home_visibility.db"

# Provide an easy way for the user to set the desired position
# by adjusting the user offset field. Write to the .A field to do this.
record(calcout, "$(P)$(M):Calibrate") {
   field(INPB, "$(P)$(M).DRBV")
   field(CALC, "A-B")
   field(OOPT, "Every Time")
   field(DOPT, "Use CALC")
   field(OUT, "$(P)$(M).OFF PP")
}

#Record describing the loop status 
record(mbbo, "$(P)$(M):LOOP") {
  field(DESC, "Loop status")
  field(ZRST, "open_loop")        field(ZRVL, "1")
  field(ONST, "feedback_loop")    field(ONVL, "2")
  field(TWST, "closed_loop")      field(TWVL, "3")
  field(VAL, "$(LOOP=0)")
}

#Record describing the loop status 
record(stringout, "$(P)$(M):STAGE_TYPE") {
  field(DESC, "Stage or Load type")
  field(VAL, "$(STAGE_TYPE=)")
}

menu(menuLOOP) {
    choice(menuLoopopen_loop, "open_loop")
    choice(menuLoopclosed_loop, "closed_loop")
    choice(menuLoopclosed_loop, "activeclosed_loop")
}

#Instructive User input value without actuation 
record(longout, "$(P)$(M):TargetVal") 
{ 
  field(DESC,"Input without move")
  field(DTYP,"Soft Channel")
}

#LOPR for TargetVal from motor record
record(calcout,"$(P):$(M):LowLim")
{
   field(PINI, "YES")
   field(DESC,"Low limit Motor value")
   field(CALC,"A")
   field(INPA,"$(P)$(M).LLM CP MS")
   field(OUT,"$(P)$(M):TargetVal.LOPR")
}

#HOPR for TargetVal from motor record
record(calcout,"$(P):$(M):HighLim")
{
   field(PINI, "YES")
   field(DESC,"High limit Motor value")
   field(CALC,"A")
   field(INPA,"$(P)$(M).HLM CP MS")
   field(OUT,"$(P)$(M):TargetVal.LOPR")
}

#Instructive move command 
record(calcout, "$(P)$(M):DoMove")
{
   field(INPA, "$(P)$(M):TargetVal")
   field(CALC, "A")
   field(OOPT, "Every Time")
   field(DOPT, "Use CALC")
   field(OUT, "$(P)$(M).DVAL PP")
}

#Load the records that extract some driver parameters directly
include "asyn_motor_records.template"
